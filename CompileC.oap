// - обозначение переведенных в комментарии старых ФУ
\* date *\ //- последняя дата изменения или добавления строк и ФУ

NewFU={Mnemo="Main_Bus" MkBegRange=1000 FUType=FUBusNew} // Описание Bus

\\ Для создания индексного файла сначала надо запустить программу !!!!
 CapsManager.IndexVectCreate=20000
 CapsManager.IpIcIdOutMk=MainBus.IpIcIdSet
 CapsManager.IpIcIdOutMk=VariableManager.IpIcIdSet
 CapsManager.IpIcIdOutMk=ListSyntez.IpIcIdSet
 MainBus.ModeSet=1
\\ -------------------------------------- \\
MainBus.FUTypeCorrectSet=-96 // Корректировка номера типа ФУ для переноса на новую ОА-платформу

NewFU={Mnemo="Console" FUType=FUConsNew Hint="Консоль для вывода логов"}
NewFU={Mnemo="Str_Gen" FUType=FUStrGenNew Hint="Генератор строк"}
NewFU={Mnemo="Stack" FUType=FUListNew Hint="Программный стек для генераци ОА-графа"}
NewFU={Mnemo="MnemoTable" FUType=FUListNew Hint="Таблица мнемоник"}
NewFU={Mnemo="Lex" FUType=FULexNew Hint="Устройство лексического разбора"}
NewFU={Mnemo="AtrCounter" FUType=FUIntAluNew Hint="Счетчик атрибутов"}
NewFU={Mnemo="MkCalc" FUType=FUIntAluNew Hint="Калькулятор для вычисления индекса МК"}
NewFU={Mnemo="BackCloneCounter" FUType=FUIntAluNew Hint="Счетчик обратных записей"}
NewFU={Mnemo="MkTable" FUType=FUListNew Hint="ФУ для Поиска МК"}
NewFU={Mnemo="OAList" FUType=FUListNew Hint="ФУ для генерации ОА-графа"}
NewFU={Mnemo="CreateNewFU" FUType=FUListNew Hint="ФУ для создания нового ФУ"}
NewFU={Mnemo="ALUG" FUType=FUALUNew Hint="ФУ для создания нового ФУ"}
NewFU={Mnemo="MkAutom" FUType=FUListNew Hint="Автомат для разбора МК"}

NewFU={Mnemo="Root" FUType=FUListNew Hint="Стартовое состояние"}
NewFU={Mnemo="EqualWait" FUType=FUListNew Hint="Ожидание знака равно"}
NewFU={Mnemo="EqualAfter" FUType=FUListNew Hint="Ожидание символов после знака равно"}
NewFU={Mnemo="ListAfter" FUType=FUListNew Hint="Ожидание символов после знаков начала новой линии"}
NewFU={Mnemo="ListAfterMnemo" FUType=FUListNew Hint="Ожидание символов после знаков начала новой линии за объявлением мнемоники"}
//NewFU={Mnemo="ListContinue" FUType=FUListNew Hint="Продолжение заполнения списка"}
NewFU={Mnemo="MnemoLoad" FUType=FUListNew Hint="Загрузка мнемоники"}
//NewFU={Mnemo="MnemoLoad2" FUType=FUListNew Hint="Загрузка мнемоники2"}
//NewFU={Mnemo="MnemoLoad3" FUType=FUListNew Hint="Загрузка мнемоники3"}
//NewFU={Mnemo="EqualWait2" FUType=FUListNew Hint="Ожидание знака равно"}
//NewFU={Mnemo="VarWait" FUType=FUListNew Hint="Ожидание переменной"}
//NewFU={Mnemo="ExprWait" FUType=FUListNew Hint="Ожидание выражения"}
//NewFU={Mnemo="ALEAnalysis" FUType=FUListNew Hint="Анализ выражения"}
NewFU={Mnemo="FUAfter" FUType=FUListNew Hint="После имени ФУ"}
NewFU={Mnemo="MkWait" FUType=FUListNew Hint="Ожидание МК"}
NewFU={Mnemo="LoadAfter" FUType=FUListNew Hint="Ожидание символов после описания нагрузки"}
NewFU={Mnemo="LoadAfter" FUType=FUListNew Hint="Ожидание символов после описания нагрузки"}

NewFU={Mnemo="LoadMnemoBack" FUType=FUListNew Hint="Ожидание закрывающейся скобки после именованной нагрузки"} \* 15/03.2023 *\
NewFU={Mnemo="LoadEnd" FUType=FUListNew Hint="Ожидание '!' после именованной нагрузки нагрузки"} \* 15/03.2023 *\

NewFU={Mnemo="MnemoAnalysis" FUType=FUListNew Hint="Анализ мнемоники"}
NewFU={Mnemo="ConstWait" FUType=FUListNew Hint="Ожидание константы"}
NewFU={Mnemo="ConstWait2" FUType=FUListNew Hint="Ожидание константы2"}
NewFU={Mnemo="VarIniWait" FUType=FUListNew Hint="Ожидание инициализации переменной"}
//NewFU={Mnemo="VarIniWait2" FUType=FUListNew Hint="Ожидание инициализации переменной2"}
NewFU={Mnemo="LoadVar" FUType=FUListNew Hint="Ожидание переменной в качестве нагрузки ИП"}
NewFU={Mnemo="LoadVarFU" FUType=FUListNew Hint="Ожидание точки после мнемоники ФУ"}
NewFU={Mnemo="BrackLoadVar" FUType=FUListNew Hint="Ожидание ) после описания переменной в качестве нагрузки ИП"}

NewFU={Mnemo="AtrRefLoad" FUType=FUListNew Hint="Ожидание скобки для загрузки ссылки на атрибут"} \* 05.03.2023 *\
NewFU={Mnemo="AtrRefWait" FUType=FUListNew Hint="Ожидание ссылки на атрибут"} \* 05.03.2023 *\
NewFU={Mnemo="AtrRefBrackWait" FUType=FUListNew Hint="Ожидание завершающей скобки загрузки ссылки на атрибут"} \* 05.03.2023 *\
NewFU={Mnemo="MkBrackWait" FUType=FUListNew Hint="Ожидание завершающей скобки загрузки МК"} \* 05.03.2023 *\

NewFU={Mnemo="BackRecLoad" FUType=FUListNew Hint="Ожидание скобки загрузки атрибута в Backrec"} \* 05.03.2023 *\
NewFU={Mnemo="BackRecAtrWait" FUType=FUListNew Hint="Ожидание атрибута для Backrec"} \* 05.03.2023 *\
NewFU={Mnemo="BackRecBrackWait" FUType=FUListNew Hint="Ожидание завершающей скобки загрузки атрибута в Backrec"} \* 05.03.2023 *\
NewFU={Mnemo="VarRoot" FUType=FUListNew Hint="Обработка var в Root"} \* 24.04.2023 *\

// Работа с векторами
NewFU={Mnemo="VectWait" FUType=FUListNew Hint="Ожидание элемента вектора"}
NewFU={Mnemo="VectNext" FUType=FUListNew Hint="Ожидание возможного следующего элемента вектора"}
NewFU={Mnemo="VectNext2" FUType=FUListNew Hint="Ожидание возможного следующего элемента вектора"} \* 05.03.2023 *\
NewFU={Mnemo="ALECheck" FUType=FUListNew Hint="Ожидание оператора"} \* 10.03.2023 *\
NewFU={Mnemo="ALECheck2" FUType=FUListNew Hint="Ожидание оператора"} \* 10.03.2023 *\
NewFU={Mnemo="ALEAfter" FUType=FUListNew Hint="Ожидание скобки после АЛЕ в нагрузке с мнемоникой"} \* 11.03.2023 *\

// Работа с АЛВ
NewFU={Mnemo="ALE" FUType=FUListNew Hint="Начальное состояние"}
NewFU={Mnemo="OpPriority" FUType=FUListNew Hint="Таблица приоритетов операций"}
NewFU={Mnemo="End" FUType=FUListNew Hint="Конечное состояние"}
NewFU={Mnemo="VarAfter" FUType=FUListNew Hint="Ожидание символа после переменной"}
NewFU={Mnemo="VectAfter" FUType=FUListNew Hint="Ожидание символа после вектора"}
NewFU={Mnemo="VectAleWait" FUType=FUListNew Hint="Ожидание символа после вектора 2"}
NewFU={Mnemo="VectAleAfter" FUType=FUListNew Hint="Ожидание символа после вектора 2"}
NewFU={Mnemo="VectAleAfter2" FUType=FUListNew Hint="Ожидание символа после вектора 2"}
NewFU={Mnemo="EqAleWait" FUType=FUListNew Hint="Перечисление переменных"}
NewFU={Mnemo="EqAleWait2" FUType=FUListNew Hint="Перечисление переменных"} \* 05.03.2023 *\
NewFU={Mnemo="EqAleWait3" FUType=FUListNew Hint="Перечисление переменных"} \* 05.03.2023 *\
NewFU={Mnemo="EqAleWait4" FUType=FUListNew Hint="Перечисление переменных"} \* 05.03.2023 *\
NewFU={Mnemo="FuncAfter" FUType=FUListNew Hint="Перечисление функций"} \* 05.03.2023 *\
NewFU={Mnemo="EqAfter" FUType=FUListNew Hint="Перечисление переменных 2"}
NewFU={Mnemo="EqAleAfter" FUType=FUListNew Hint="Ожидание символа после перечисления переменных"}
NewFU={Mnemo="FuncAfter" FUType=FUListNew Hint="Ожидание функции"}
NewFU={Mnemo="OperatWait" FUType=FUListNew Hint="Ожидание оператора"}
NewFU={Mnemo="OpTranslate" FUType=FUListNew Hint="Список операторов для трансляции в ОА-коды"}
NewFU={Mnemo="AccumEqwList" FUType=FUListNew Hint="Список операций присвоения с накоплением"}
NewFU={Mnemo="FuncALE1ArgAfter" FUType=FUListNew Hint="Ожидание операнда после АЛ функции с одним аргументом"}
NewFU={Mnemo="FuncALEAfter" FUType=FUListNew Hint="Ожидание операнда после АЛ функции"}
NewFU={Mnemo="MinusALECheck" FUType=FUListNew Hint="Проверка минуса перед функцией в АЛВ"}
NewFU={Mnemo="Func1ArgAfter" FUType=FUListNew Hint="Проверка после функции одного аргумента"}

// Работа с императивными конструкциями
NewFU={Mnemo="IfAfter" FUType=FUListNew Hint="Ожидание фигурной скобки после операции if"} \* 05.03.2023 *\
NewFU={Mnemo="ElseAfter" FUType=FUListNew Hint="Ожидание фигурной скобки после операции else"} \* 05.03.2023 *\
NewFU={Mnemo="ElseWait" FUType=FUListNew Hint="Ожидание else после закрытия фигурной скобки конструкции if"} \* 05.03.2023 *\
NewFU={Mnemo="ForVect" FUType=FUListNew Hint="Ожидание потока или открывающейся векторной скобки в цикле for/after"} \* 21.04.2023 *\
NewFU={Mnemo="ForFirstArg" FUType=FUListNew Hint="Ожидание потока, выражения или двоеточия для указания конца диапазона в цикле for/after"} \* 21.04.2023 *\
NewFU={Mnemo="ForSecArgWait" FUType=FUListNew Hint="Ожидание значения конца диапазона в цикле for/after"} \* 21.04.2023 *\
NewFU={Mnemo="ForFirstArgAfter" FUType=FUListNew Hint="Ожидание потока или двоеточия для указания конца диапазона в цикле for/after"} \* 21.04.2023 *\
NewFU={Mnemo="ForSecArg" FUType=FUListNew Hint="Ожидание потока, выражения или двоеточия для указания шага диапазона в цикле for/after"} \* 21.04.2023 *\
NewFU={Mnemo="ForThirdArgWait" FUType=FUListNew Hint="Ожидание значения шага диапазона в цикле for/after"} \* 21.04.2023 *\
NewFU={Mnemo="ForSecArgAfter" FUType=FUListNew Hint="Ожидание потока или двоеточия для указания шага диапазона в цикле for/after"} \* 21.04.2023 *\
NewFU={Mnemo="ForThirdArg" FUType=FUListNew Hint="Ожидание потока или выражения в блоке цикла for/after"} \* 21.04.2023 *\
NewFU={Mnemo="ForAfter" FUType=FUListNew Hint="Ожидание потока в блоке цикла for/after"} \* 21.04.2023 *\
NewFU={Mnemo="ForElseWait" FUType=FUListNew Hint="Ожидание else в потоке в блоке цикла for/after"} \* 23.04.2023 *\
NewFU={Mnemo="ForElseAfter" FUType=FUListNew Hint="После else в блоке цикла for/after"} \* 23.04.2023 *\
NewFU={Mnemo="BreakAfter" FUType=FUListNew Hint="После Break/next в блоке цикла for/after"} \* 23.04.2023 *\

MainBus.PartialResetSet \\ Запомнить число созданных ФУ
MainBus.ModeSet=2

Sep*-4
Var*-14
//Const*-13
//Mk*-24
FU*-300 // Индекс ФУ
MkForFU*-301 // Мк для ФУ
IC*-102 // Мк для ФУ
//FUType*-22
//NameAtr*-72
FUTemplate*-303
MkExec*-304 // МК для последующего выполнения
BackVar*-305 // Переменная для обратной записи
Vect*-306 // Вектор нагрузок
MkBrack*-307 // Скобка для милликоманд FU(.Mk .Mk)
MnemoLoadBrack*-308 // Скобка для мнемоники нагрузки
IP*-309 // ИП
LineAtr*-6 // Метка линии списка

AleSep*-309 // Разделитель для АЛВ
AleStackUp*-310 // Подняться на одну позицию вверх по стеку в АЛВ 
Ternar*-311 // Маркер тернарной конструкции в стеке
//Func*-78
Func1Arg* -312 // Функция с одним алгументом
FuncALE* -313  // Функция для АЛУ
FuncALE1Arg*-314 // Одноаргументная функция для ФУ ФЛУ
FuncALE1ArgBracket*-315 // Функция с одним аргументов с круглой скобкой
IfAtr*-316 // Атрибут операции if
ElseAtr*-317 // Атрибут операции else
ForAtr*-318 // Атрибут цикла for
ForElseAtr*-319 // Атрибут цикла for

// FU*-100
//Hint*=-42

Console.QuoteSet=""
Console.AtrMnemoAdd={FUALUNew.AnsFix="AnsFix" 2002="Cons.OutLn" -6="Line"
  ProgExec="Exec" FUALUNew.PushExec="PushExec" FUALUNew.PushCycleExec="PushCycleExec"  FUALUNew.PushPostCycleExec="PushPostCycleExec"
  FUALUNew.Set="Set" ProgStop="ProgStop" FUALUNew.AnsOutMk="AnsOutMk" FUALUNew.AnsOut="AnsOut" FUALUNew.Sum="Add"
  FUALUNew.Smaller="Smaller" NoProg="NoProg"
  -316="IfAtr"; -317="ElseAtr"; -318="ForAtr"; -319="ForElseAtr"
  FUALUNew.OutAdrAppend="OutAdrAppend"
}

MkTable.FailProgSet={Console.OutLn="MK is not found MkTable" Lex.Stop}

AtrCounter.Set=-10000 // Начальный индекс атрибута
AtrCounter.StepSet=-1
MkCalc.NoIntTypeErrProg={ // Ошибка записи нецелого числа в качестве МК
	Console.OutLn="Integer is expected"
	Lex.Stop Str_Gen.Stop}

Lex.UnicAtrSet=Mnemo
Lex.UnicMkSet=MnemoTable.FindAnd
Lex.StopProgSet={Str_Gen.Stop}

CommonMkTable
	>{Mnemo="ContextOut" Mk=995 Hint="Выдать указатель на контекст ФУ"}
	>{Mnemo="ContextOutMk" Mk=999 Hint="Выдать милликоманду с указателем на контекст ФУ"}

\**\ConsMkTable
>{Mk=1 Mnemo="Out" Hint="Вывод"}
>{Mk=2 Mnemo="OutLn" Hint="Вывод и перевод строки"}
>{Mk=10 Mnemo="Ln" Hint="Перевод строки"}

\**\BusMkTable
>{Mk=1 Mnemo="MakeFU" Hint="Создать ФУ (в нагрузке передаётся тип ФУ)"}
>{Mk=5 Mnemo="ProgExec" Hint="Выполнить последовательность МК из ИК"}
>{Mk=10 Mnemo="FileOldProgExec" Hint="Выполнить последовательность МК из индексного файла старого формата"}
>{Mk=20 Mnemo="NFUOut" Hint="Выдать количество ФУ, подключенных к шине"}
>{Mk=20 Mnemo="NFUOutMk" Hint="Выдать МК с количеством ФУ, подключенных к шине"}
//>CommonMkTable

MnemoTable.FailProgSet={FUListNew.ReceivedOutMk=Lex.SendToReceiver}
\**\MnemoTable.Set= //         Таблица мнемоник
//>{Mnemo="NewFU" Stack.LineCopyAdd={MkExec} Lex.SendToReceiver={Mk=Console.OutLn}}
>{Mnemo="NewFU" Stack.LineCopyAdd={MkExec} Lex.SendToReceiver={Mk=CreateNewFU.FindOr}
	Console.Out="NewFU " Console.OutLn=CreateNewFU.FindOr
  }
>{Mnemo="Console"   Lex.SendToReceiver={FUType=2} }
>{Mnemo="FUConsole" Lex.SendToReceiver={FUTypeList=ConsMkTable} }
>{Mnemo="FUBus"     Lex.SendToReceiver={FUTypeList=BusMkTable} }
>{Mnemo="sin" 		 Lex.SendToReceiver={FuncALE1Arg=FUALUNew.Sin} }
>{Mnemo="max" 		 Lex.SendToReceiver={FuncALE=FUALUNew.MaxVect} }
>{Mnemo="ConsOut"   Lex.SendToReceiver={Mk=Console.OutLn}}
>{Mnemo="Obj" 		 Lex.SendToReceiver={Atr=-6} }
>{Mnemo="Atr"    	 Lex.SendToReceiver={Atr=Atr}}
>{Mnemo="Mnemo"  	 Lex.SendToReceiver={Atr=Mnemo}}
>{Mnemo="Name"  	 Lex.SendToReceiver={Atr=NameAtr}}
>{Mnemo="FUType" 	 Lex.SendToReceiver={Atr=FUType}}
>{Mnemo="Hint"   	 Lex.SendToReceiver={Atr=Hint}}
>{Mnemo="FUCons" 	 Lex.SendToReceiver={Const=1} Console.OutLn="FUCons !"}
>{Mnemo="Bus" Hint="Главная шина" MkTable.Set=BusMkTable! Lex.SendToReceiver={FU=1000}}
>{Mnemo="Cons" Hint="Консоль вывода" MkTable.Set=ConsMkTable! Lex.SendToReceiver={FU=2000}}

CreateNewFU.MultiLineModeSet=1
\**\CreateNewFU.Set=
>{FUTemplate CreateNewFU.LoadReceivedOutMk=MainBus.Create}
>{FUType FUListNew.LoadReceivedOutMk=MainBus.Create}
>{NameAtr  FUListNew.IpReceivedOutMk=MnemoTable.LineCopyAdd MnemoTable.LineCopyAdd={FU} Main_Bus.LastFUMkRangeOutMk=MnemoTable.LastLoadSet
 FUListNew.LoadReceivedOutMk=Main_Bus.LastFUNameSet}
>{Hint Console.OutLn="Hint" FUListNew.IpReceivedOutMk=MnemoTable.LineCopyAdd}

Lex.ReceiverMkSet=Root.FindAnd

ListCheckProg // Программа проверки спискаNewFU={Mnemo="" FUType=}
{
  Stack.FindAndLast={Sep=">"}
  Stack.SuccessExec={Stack.LastPopMk OAList.PopMk Console.OutLn="List check > success!!!"}
}

\**\IfAfter.Set=
>{Sep="{" Lex.ReceiverMkSet=Root.FindAnd 
Console.OutLn="IfAfter {"
  OAList.LastAttach={YesProgBreak}
  OAList.LineCopyAddPrevLoadSet
}
>{Sep=">>" Sep=">>|" Lex.ReceiverMkSet=Root.FindAnd
Console.OutLn="IfAfter >>"
  OAList.LastAttach={YesProgBreak}
  OAList.LineCopyAddPrevLoadSet={ProgStop=2}
//  OAList.LastPopMk
//  OAList.LastPopMk
}
>{0 Lex.Stop Console.OutLn="'{' is expected" FUListNew.ReceivedOutMk=Console.OutLn}

\**\ElseAfter.Set=
>{Sep="{" Lex.ReceiverMkSet=Root.FindAnd
//  Stack.LineCopyAdd={ElseAtr}
  Stack.LastPopMk
  Stack.LineCopyAdd={ElseAtr}
Console.OutLn="ElseAfter {"
}
>{0 Lex.Stop Console.OutLn="'{' is expected"}

\**\ElseWait.Set=
>{Mnemo="else" Lex.ReceiverMkSet=ElseAfter.FindAnd
//  OAList.PopMk
Console.OutLn="ElseWait else"
}
>{Mnemo="elif" Lex.ReceiverMkSet=IfAfter.FindAnd Lex.ReceiverPush=EqAleAfter.FindAnd
  OAList.PopMk
  OAList.LastAttach={FUALUNew.Set}
Console.OutLn="ElseWait elif"
}
>{0 Lex.ReceiverMkSet=Root.FindAnd
Console.OutLn="ElseWait end of if"
FUListNew.ReceivedOutMk=Console.OutLn
//OAList.OutMk=Console.OutLn
  OAList.LastPopMk
  Stack.LastDelMk
 // OAList.LastPopMk
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
  }


//////////////////////////////////////////
///////////////  For  ////////////////////
\* 21.04.2023 *\

\**\ForElseWait.Set=
>{Mnemo="else" Lex.ReceiverMkSet=ForElseAfter.FindAnd
Console.OutLn="ForElseWait 'else'"
  OAList.LastPopMk
  Stack.LastLoadOutMk=OAList.LineAdd
  Stack.LastDelMk
//  Stack.LineCopyAdd={Sep="{"}
  Stack.LineCopyAdd={ForElseAtr}
}
>{0 Lex.ReceiverMkSet=Root.FindAnd
  Stack.LastDelMk
  OAList.LastPopMk
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
Console.OutLn="ForElseWait else"
}

\**\ForElseAfter.Set=
>{Sep="{" Sep=">>" Lex.ReceiverMkSet=Root.FindAnd
Console.OutLn="ForElseAfter { >>"
}
>{0 Lex.Stop Console.OutLn="'>>' or '{ is expected"}

\**\ForAfter.Set=
>{Const Var Sep="(" Lex.ReceiverMkSet=ForFirstArg.FindAnd
//  OAList.LastAttach={FUALUNew.AnsFix}
  Stack.LineCopyAdd={IfAtr}// Атрибут стека для того, чтобы автомат АЛВ не удалял АЛВ из стека
  OAList.LineCopyAdd={FUALUNew.Set}
  Lex.ReceiverPush=EqAleAfter.FindAnd
Console.OutLn="ForAfter  Const Var ALE"
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}
>{Vect Lex.ReceiverMkSet=ForVect.FindAnd
  Console.OutLn="ForAfter Vect"
}
>{0 Lex.Stop Console.OutLn="For description error"}

\**\ForVect.Set=
>{Sep="[" Lex.ReceiverMkSet=ForFirstArgAfter.FindAnd Lex.ReceiverPush=EqAleAfter.FindAnd
  Console.OutLn="Vect ["
  //Stack.LineCopyAdd={}
  OAList.LineCopyAdd={FUALUNew.ProgExec}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
}
>{Sep=">>" Lex.ReceiverMkSet=Root.FindAnd
  Stack.FindAndLast={Mnemo="for"}
  Stack.FailExec={Lex.Stop ForAfter.ProgStopAll Console.OutLn="'for' is expected"}
  Stack.LastDelMk

  ForAfter.ReceivedLoadOut=temp
  ForAfter.ReceivedLoadOut=tmp
  OAList.LastTreeCopyAttach=TCaps2{
    FUALUNew.Set=0 FUALUNew.PushCycleExec={
      FUALUNew.PushExec={
        FUALUNew.VectToIndSet=tmp(nil)! FUALUNew.VectIndErrExec=ForElseProg2{ProgStop=4}
      }
      FUALUNew.PushExec={
        FUALUNew.VectToIndSet=temp(nil)!
        ProgExec=ForProg2{FUALUNew.AnsFix}
      }
      FUALUNew.Sum=1
    }
  }
  OAList.CopyAdrCorrectOriginalSet=TCaps2!
  OAList.LastOutMk=OAList.CopyAdrCorrectCopylSet

  OAList.CopyAdrCorrectAdrSet=ForElseProg2!
  OAList.CopyAdrCorrectAdrOut=t Stack.LineCopyAdd={ForAtr=t(nil)!}
  OAList.CopyAdrCorrectAdrSet=ForProg2!
  OAList.LastPopMk
  OAList.CopyAdrCorrectAdrOutMk=OAList.LineAdd
}

\**\ForFirstArg.Set=
>{Sep=">>" Lex.ReceiverMkSet=Root.FindAnd
Console.OutLn="&&&&&&"
  OAList.LastPopMk=OAList.Receive
  OAList.LastAttach={FUALUNew.Set=0}
  Stack.LastDelMk

  Stack.FindOrLast={Mnemo="for"}
  Stack.SuccessExec={OAList.LastAttach={FUALUNew.PushCycleExec} Console.OutLn="ForType for"}
  Stack.FailExec={OAList.LastAttach={FUALUNew.PushPostCycleExec} Console.OutLn="ForType after"}
  Stack.LastDelMk

  OAList.LineCopyAddPrevLoadSet={FUALUNew.AnsFix FUALUNew.PushExec}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.ProgExec}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Smaller}
  OAList.ReceivedOutMk=OAList.LastLoadSet
  OAList.LastPopMk
  OAList.LastTreeCopyAttach={NoProg={ProgStop=4}}
  OAList.LastLoadOut=t Stack.LineCopyAdd={ForAtr=t(nil)!}
  OAList.LastPopMk
  OAList.LastAttach={ProgExec}
  OAList.LineCopyAddPrevLoadSet
  OAList.LastPopMk=OAList.Receive
  OAList.LastTreeCopyAttach={ProgExec={FUALUNew.Sum=1}}
  OAList.LastPopMk
  OAList.LastPopMk
  OAList.ReceivedOutMk=OAList.LineAdd

//  OAList.OutMk=Console.OutLn

//Console.OutLn="Stack:"
//Stack.OutMk=Console.OutLn
}
>{Sep=":" Lex.ReceiverMkSet=ForSecArg.FindAnd
  OAList.LastPopMk=OAList.Receive
  OAList.LastAttach={FUALUNew.Set}
  OAList.ReceivedOutMk=OAList.LastLoadSet
  
  Stack.LastDelMk
  Stack.FindOrLast={Mnemo="for"}
  Stack.SuccessExec={OAList.LastAttach={FUALUNew.PushCycleExec} Console.OutLn="ForType for +"}
  Stack.FailExec={OAList.LastAttach={FUALUNew.PushPostCycleExec} Console.OutLn="ForType after +"}
  Stack.LastDelMk

  OAList.LineCopyAddPrevLoadSet={FUALUNew.AnsFix FUALUNew.PushExec}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.ProgExec}
    
  Console.OutLn="ForFirstArg Const Var"

  OAList.LineCopyAdd={FUALUNew.Set}
  Stack.LineCopyAdd={IfAtr} // Чтобы не удалалось синтезированное АЛВ из OAList

  Lex.ReceiverMkSet=ForSecArg.FindAnd
  Lex.ReceiverPush=EqAleAfter.FindAnd
}

>{0 Lex.ReceiverMkSet=ForFirstArgAfter.FindAnd 
  Lex.ReceiverPush=EqAleAfter.FindAnd
  Console.OutLn="for/after const/var ALE"
  ForAfter.ReceivedOutMk=Lex.SendToReceiver
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}

\**\ForFirstArgAfter.Set=
>{Sep=":" Lex.ReceiverMkSet=ForSecArg.FindAnd}
>{Sep=">>" Lex.ReceiverMkSet=Root.FindAnd

}

\**\ForSecArgWait.Set=
>{Const Var Lex.ReceiverMkSet=ForSecArg.FindAnd
Console.OutLn="ForSecArgWait Const Var"
}

LogEqOperations{ // Логические операции и операции сравнения
  FUALUNew.And FUALUNew.Or FUALUNew.Xor FUALUNew.Not
  FUALUNew.NotEQ FUALUNew.EQ FUALUNew.Bigger FUALUNew.BiggerEQ FUALUNew.Smaller FUALUNew.SmallerEQ
}

\**\ForSecArg.Set=
>{Sep=">>" Lex.ReceiverMkSet=Root.FindAnd
  Stack.LastDelMk // Удалить IfAtr
  OAList.LastPopMk=OAList.Receive
Console.OutLn="ForSecArg >>"

//OAList.OutMk=Console.OutLn
  
  Stack.LineAdd=LogEqOperations
  OAList.ReceivedOutMk=Stack.FindOrLast
  Stack.FailExec={
    OAList.LineCopyAddPrevLoadSet={FUALUNew.Smaller}
    OAList.ReceivedOutMk=OAList.LastLoadSet
    OAList.LastPopMk
  }
  Stack.LastPopMk

  OAList.LastTreeCopyAttach={NoProg={ProgStop=4}}
  OAList.LastLoadOut=t Stack.LineCopyAdd={ForAtr=t(nil)!}
  OAList.LastPopMk

  OAList.LastAttach={ProgExec}
  OAList.LineCopyAddPrevLoadSet
  OAList.LastPopMk=OAList.Receive
  OAList.LastTreeCopyAttach={ProgExec={FUALUNew.Sum=1}}
  OAList.LastPopMk
  OAList.LastPopMk
  OAList.ReceivedOutMk=OAList.LineAdd
}
>{Sep=":" Lex.ReceiverMkSet=ForThirdArgWait.FindAnd
  Console.OutLn="ForSecArgWait Const Var"
  Stack.LastDelMk // Удалить IfAtr
  OAList.LastPopMk=OAList.Receive
  
  Stack.LineAdd=LogEqOperations
  OAList.ReceivedOutMk=Stack.FindOrLast
  Stack.FailExec={
    OAList.LineCopyAddPrevLoadSet={FUALUNew.Smaller}
    OAList.ReceivedOutMk=OAList.LastLoadSet
    OAList.LastPopMk
  }
  Stack.LastPopMk

  OAList.LastTreeCopyAttach={NoProg={ProgStop=4}}
  OAList.LastLoadOut=t Stack.LineCopyAdd={ForAtr=t(nil)!}
  OAList.LastPopMk

  OAList.LastAttach={ProgExec}
  OAList.LineCopyAddPrevLoadSet
  OAList.LastPopMk=OAList.Receive
  OAList.LastAttach={ProgExec}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Sum}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}

  Lex.ReceiverMkSet=ForThirdArg.FindAnd
  Lex.ReceiverPush=EqAleAfter.FindAnd
}
>{0 Lex.ReceiverMkSet=ForSecArgAfter.FindAnd 
  Lex.ReceiverPush=EqAleAfter.FindAnd
  Console.OutLn="for/after const/var:const/var ALE"
  ForSecArgWait.ReceivedLoadOutMk=Lex.SendToReceiver
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}

\**\ForThirdArgWait.Set=
>{Const Var Lex.ReceiverMkSet=ForThirdArg.FindAnd}
>{0 Lex.Stop Console.OutLn="for construction wrong description ForThirdArgWait"}

\**\ForSecArgAfter.Set=
>{Sep=">>" Lex.ReceiverMkSet=Root.FindAnd}
>{Sep=":" Lex.ReceiverMkSet=ForThirdArgWait.FindAnd}
>{0 Lex.Stop Console.OutLn="for construction wrong description ForSecArgAfter"}

\**\ForThirdArg.Set=
>{Sep=">>" Lex.ReceiverMkSet=Root.FindAnd
//  OAList.OutMk=Console.OutLn

  OAList.LastPopMk
  OAList.LastPopMk
  OAList.LastPopMk
  OAList.LastPopMk
  OAList.ReceivedOutMk=OAList.LineAdd // Добавить в OAList ссылку на тело программы цикла
}
>{0 Lex.ReceiverMkSet=ForAfter.FindAnd 
  Lex.ReceiverPush=EqAleAfter.FindAnd
  Console.OutLn="for/after const/var:const/var:const/var ALE"
  ForThirdArgWait.ReceivedLoadOutMk=Lex.SendToReceiver
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}

\**\BreakAfter.Set=
>{Var Const FUListNew.ReceivedLoadOutMk=OAList.LastLoadSet Lex.ReceiverMkSet=Root.FindAnd}
>{0 Lex.ReceiverMkSet=Root.FindAnd FUListNew.ReceivedOutMk=Lex.SendToReceiver}

///////////////  For  ////////////////////
//////////////////////////////////////////

\**\Root.Set=
>{Mnemo="break" Console.OutLn="break !!!!"
 Lex.ReceiverMkSet=BreakAfter.FindAnd OAList.LastAttach={Break} }
>{Mnemo="next" Lex.ReceiverMkSet=BreakAfter.FindAnd OAList.LastAttach={Next} }

>{Mnemo="for" Lex.ReceiverMkSet=ForAfter.FindAnd
  OAList.LastAttach={FUALUNew.PushExec}
  OAList.LineCopyAddPrevLoadSet
  Stack.LineCopyAdd={Mnemo="for"}
  Console.OutLn="for Root"
}
>{Mnemo="after" Lex.ReceiverMkSet=ForAfter.FindAnd
  OAList.LastAttach={FUALUNew.PushExec}
  OAList.LineCopyAddPrevLoadSet
  Stack.LineCopyAdd={Mnemo="after"}
  Console.OutLn="after"
}

>{Mnemo="if" Lex.ReceiverMkSet=IfAfter.FindAnd Lex.ReceiverPush=EqAleAfter.FindAnd
Console.OutLn="Root if"
  Stack.LineCopyAdd={IfAtr}
//  OAList.LineCopyAdd={FUALUNew.PushExec}
  OAList.LastAttach={FUALUNew.PushExec}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
}
>{Mnemo="else" Lex.ReceiverMkSet=Root.FindAnd Lex.ReceiverPush=EqAleAfter.FindAnd
  
}
>{Sep="" Console.OutLn="End of program!!!"
  Stack.FindAndLast={MkExec}
  Stack.SuccessExec={Console.OutLn="MkExecSuссess" Stack.LastDelMk Console.OutLn="MkExec" OAList.LastIpPopMk=Main_Bus.MkExec}
}
>{FU
  //Prog=ListCheckProg
  Lex.ReceiverPush=MkAutom.FindAnd
Console.OutLn="FU Root"
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}
>{Sep="." Lex.ReceiverPush=MkAutom.FindAnd
      Stack.FindAndLast={MkBrack}
     Stack.FailExec={Lex.Stop Console.OutLn="Fu name is expected" ProgStopAll}
     Stack.LastLoadOut=t Lex.SendToReceiver={FU=t(nil)!}
	Lex.SendToReceiver={Sep="."}
}
>{Sep=")" Lex.ReceiverMkSet=Root.FindAnd
  Stack.FindAndLast={MkBrack}
    Stack.FailExec={Lex.Stop Console.OutLn=" ')' without '('" ProgStopAll Stack.OutMk=Console.OutLn}
  Stack.PopMkDel
}
>{Mk Lex.ReceiverMkSet=EqualWait.FindAnd
//  Console.OutLn="MK - OAList:"
//  OAList.OutMk=Console.OutLn
  Prog=ListCheckProg
  OAList.LastAttach
//Console.Out="Mk+ " FUListNew.ReceivedLoadOutMk=Console.OutLn
  FUListNew.ReceivedLoadOutMk=OAList.LastAtrSet
//  Console.OutLn="OAList:"
//  OAList.OutMk=Console.OutLn
  }
>{Atr Lex.ReceiverMkSet=EqualWait.FindAnd
  Prog=ListCheckProg
  OAList.OneLineExec={Lex.Stop Console.OutLn="Attribute on first lavel of OA graph" ProgStopAll
//  OAList.OutMk=Console.OutLn
  }
  OAList.LastAttach
  FUListNew.ReceivedLoadOutMk=OAList.LastAtrSet
  Console.OutLn="Atr of Root"
  }
>{Mnemo Lex.ReceiverMkSet=MnemoAnalysis.FindAnd
  Prog=ListCheckProg
  OAList.MoreOneLineExec={Lex.Stop Str_Gen.Stop Console.OutLn="Mnemonics on no first lavel of OA graph" 
    Root.ReceivedOutMk=Console.OutLn
    Root.ProgStopAll}
  FUListNew.ReceivedOutMk=MnemoTable.LineCopyAdd
  MnemoTable.LastAttach={Lex.SendToReceiver}
  Console.OutLn="Mnemo1"}
>{Const \* отличие от схемы (const отсутствует!) *\
  Prog=ListCheckProg
  Lex.ReceiverMkSet=EqualWait.FindAnd
  OAList.EmptyOrOneLineExec={Console.LnOut="Constant insted MK on first lavel of OA graph" Lex.Stop ProgStopAll}
  OAList.LastAttach
  FUListNew.ReceivedLoadOutMk=OAList.LastAtrSet}
>{Var Lex.ReceiverMkSet=VarRoot.FindAnd
  Console.OutLn="Root Var"
}
\*
>{Var Lex.ReceiverMkSet=Root.FindAnd
  Console.OutLn="Root Var"
  Lex.ReceiverPush=ALE.FindAnd
  OAList.LastAttach={FUALUNew.ProgExec}
  OAList.LineCopyAddPrevLoadSet
  FUListNew.ReceivedOutMk=ALE.FindAnd // Откат (анализ с предыдущей лексемы)
}
*\
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
>{Var \* 22.03.2023 *\
  Lex.ReceiverMkSet=Root.FindAnd
  Lex.ReceiverPush=ALE.FindAnd
  FUListNew.ReceivedOutMk=Lex.SendToReceiver	
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

//>{Sep="{" Lex.ReceiverMkSet=Root.FindAnd
//Console.OutLn="Root {"
//}

>{Sep="}" Lex.ReceiverMkSet=Root.FindAnd
  Console.OutLn="Root }"
  OAList.OneDeepExec={
    OAList.OneLineExec={Console.OutLn="Wrong '}' on first level of OA-graph" Lex.Stop ProgStopAll}
  }
  Stack.FindOrLast={ElseAtr} // Конец конструкции if
  Stack.SuccessExec={Lex.ReceiverMkSet=Root.FindAnd
Console.OutLn="Root ElseAtr"
  Stack.LastDelMk
  OAList.LastPopMk
  Root.ProgStopAll
}
  Stack.FindOrLast={IfAtr} // Конец конструкции if
  Stack.SuccessExec={Lex.ReceiverMkSet=ElseWait.FindAnd
Console.OutLn="Root ifAtr"
OAList.OutMk=Cons.OutLn
    OAList.LastPopMk
//OAList.OutMk=Console.OutLn
    Root.ProgStopAll
}

  Stack.FindOrLast={ForAtr} // Конец конструкции if
  Stack.SuccessExec={Lex.ReceiverMkSet=ForElseWait.FindAnd
    Root.ProgStopAll
    Console.OutLn="To ForElseWait"
  }

  Stack.FindOrLast={Sep="{" ForElseAtr}
    Stack.FailExec={Console.OutLn="'}' without '{'" Lex.Stop 
    Stack.OutMk=Console.OutLn
    Root.ProgStopAll}
  Console.OutLn="}"
  Stack.FindOrLast={ForElseAtr}
  Stack.SuccessExec={
    OAList.LastIpHeadToTail
Console.OutLn="LastIpHeadToTail "
  OAList.LastPopMk
} // Переместить StopProg в конец ИК в конструкции for - else
  Stack.LastPopMk

//Console.OutLn="---Stack---"
//Stack.OutMk=Console.OutLn
//Console.OutLn="---OAList---"
//OAList.RootOutMk=Console.OutLn

Console.OutLn="======"
//  Stack.FindAndLast={Sep=">"}
//  Stack.SuссessExec={OAList.PopMk} // Подняться на уровень, если была линия списка
  Stack.FindAndLast={MkExec}
  Stack.SuccessExec={Console.OutLn="MkExecSuссess" Stack.LastDelMk Console.OutLn="MkExec" OAList.LastIpPopMk=Main_Bus.MkExec}
Console.OutLn="--Stack--"
Stack.OutMk=Console.OutLn
Console.OutLn="--OAList--"
//OAList.OutMk=Console.OutLn
}
>{Sep=">" Lex.ReceiverMkSet=ListAfter.FindAnd
  Stack.FindAndLast={Sep=">"}
  Stack.FailExec={Console.OutLn="Undeclareted list" Stack.OutMk=Console.OutLn Lex.Stop ProgStopAll}
  Console.OutLn="> again"
  OAList.RootOutMk=Console.OutLn
}
>{IC Lex.ReceiverMkSet=AtrRefLoad.FindAnd} \* 05.03.2023 *\
>{0 Console.OutLn="Error of Root" Lex.Stop FUListNew.ReceivedOutMk=Console.OutLn}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
\**\VarRoot.Set=
>{Sep="=" Sep="," \* 22.04.2023 *\
Console.OutLn="VarRoot = ,"
  Lex.ReceiverMkSet=Root.FindAnd
  Lex.ReceiverPush=ALE.FindAnd
  OAList.LastAttach={FUALUNew.ProgExec}
  OAList.LineCopyAddPrevLoadSet
  Root.ReceivedOutMk=ALE.FindAnd
  FUListNew.ReceivedOutMk=Lex.SendToReceiver // Откат (анализ с предыдущей лексемы)

}
>{0 Lex.ReceiverMkSet=Root.FindAnd
Console.OutLn="VarRoot else"
FUListNew.ReceivedOutMk=Console.OutLn
  Root.ReceivedLoadOut=t OAList.LastAttach={FUALUNew.AnsOut=t(nil)!} // Записать Ans в переменную
  FUListNew.ReceivedOutMk=Root.FindAnd
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


\**\MkAutom.Set=
>{FU 
Console.OutLn="FU MkAutomat"
  Lex.ReceiverMkSet=FUAfter.FindAnd
  Console.OutLn="MkAutom start"
  FUListNew.ReceivedLoadOutMk=MkCalc.Set
}
>{0 Console.OutLn="MkAutom Error" Lex.Stop}

\**\FUAfter.Set=
>{Sep="." Lex.ReceiverMkSet=MkWait.FindOr
Console.OutLn="FU."
  Lex.UnicAtrSet=Mnemo Lex.UnicMkSet=MkTable.FindOr
  MkTable.SuccessProgSet={FUListNew.LineOutMk=Lex.SendToReceiver}}
>{Sep="(" Lex.ReceiverMkSet=Root.FindAnd
  Stack.LineCopyAdd={MkBrack} MkTable.OutMk=Stack.LastLoadSet}
>{0 Console.OutLn="'.' is not found" Lex.Stop FUListNew.ReceivedOutMk=Console.OutLn}

\**\MkWait.Set=
>{Mk
  FUListNew.LoadReceivedOutMk=MkCalc.Add
Console.OutLn="'.Mk'"
//  MkCalc.AccumREfOut=t Console.OutLn={Mk=t(nil)!}
  Lex.UnicAtrSet=Mnemo Lex.UnicMkSet=MnemoTable.FindAnd
  MkCalc.AccumREfOut=t Lex.ReceiverPopSend={Mk=t(nil)!}
}
>{0 Lex.Stop Console.OutLn="Wrong Mk desription"}


\**\LoadMnemoBack.Set=
>{Sep=")" Lex.ReceiverMkSet=LoadEnd.FindAnd Console.OutLn=" "")"" "
  Stack.FindOrLast={MnemoLoadBrack}
  Stack.SuccessExec={Stack.LastDelMk Console.OutLn="Stack last del"}
  Stack.FailExec={Lex.Stop Console.OutLn="')' without '(' !!!"}
}
>{0 Lex.Stop Console.OutLn=" "")"" is not found"}

\**\LoadEnd.Set=
>{Sep="!" Lex.ReceiverMkSet=Root.FindAnd
  EqualAfter.ReceivedLoadOutMk=MnemoTable.FindOr
  MnemoTable.LineDelMk // Удаление описания мнемоники из таблицы мнемоник
}
>{0 Lex.ReceiverMkSet=Root.FindAnd Console.OutLn="LoadEnd" Lex.OutMk=Console.OutLn
  FUListNew.ReceivedOutMk=Lex.SendToReceiver}

\**\ALEAfter.Set=
>{Sep=")" Lex.ReceiverMkSet=Root.FindAnd}
>{0 Lex.Stop Console.OutLn="')' is not found"}

\**\MnemoAnalysis.Set=
>{Sep="{" Lex.ReceiverMkSet=Root.FindAnd
  OAList.MoreOneLineExec={Console.OutLn="IC inisialization on no first level of programm" Lex.Stop}
  OAList.LineCopyAdd
  MnemoTable.LineCopyAddPrevLoadSet={IC}
  OAList.LastOutMk=MnemoTable.LastLoadSet
  MnemoTable.LastPopMk
  Stack.LineCopyAdd={Sep="{"}
Console.OutLn="MnemoAnalysis {"
}
>{Sep="=" Lex.ReceiverMkSet=VarIniWait.FindAnd
//  Root.ReceivedOutMk=MnemoTable.LineCopyAdd
//  MnemoTable.LastAttach={Console.OutLn="Var in Table" Lex.SendToReceiver}
Console.OutLn="MnemoAnalysis ="
}
>{Sep=":=" Lex.ReceiverMkSet=ConstWait.FindAnd} \* 05.03.2023 *\
>{Sep="*" Lex.ReceiverMkSet=ConstWait2.FindAnd}
>{Sep=">" Lex.ReceiverMkSet=ListAfter.FindAnd
  OAList.PushCopy
  Stack.LineAdd={Sep=">"}
  MnemoTable.LineCopyAddPrevLoadSet={IC}
  OAList.OutMk=MnemoTable.LastLoadSet
  MnemoTable.LastPopMk
}
>{Sep="<" Lex.ReceiverMkSet=ListAfter.FindAnd} \* 05.03.2023 *\
>{0 Lex.ReceiverMkSet=Root.FindAnd
  MnemoTable.LineCopyAddPrevLoadSet={Atr}
  MnemoTable.LastAttach={Lex.SendToReceiver}
  AtrCounter.OutMk=MnemoTable.LastLoadCopySet // Декремент счетчика атрибутов автоматичекий
  MnemoTable.LastPopMk
  Console.OutLn="Atr MnemoAnalysis"}

\**\ConstWait.Set= \* 05.03.2023 *\
>{Const Lex.ReceiverMkSet=Root.FindAnd}
>{Sep="[" Lex.ReceiverMkSet=ALE.FindAnd}
>{0 Console.OutLn="Const error" Lex.Stop Str_Gen.Stop}

\**\ConstWait2.Set=
>{Const Lex.ReceiverMkSet=Root.FindAnd
  MnemoTable.LineCopyAddPrevLoadSet={Atr}
  FUListNew.ReceivedLoadOutMk=MkCalc.Set
  MkCalc.OutMk=MnemoTable.LastLoadSet
  MnemoTable.LastPopMk}
>{0 Console.OutLn="Integer is waiting" Lex.Stop Str_Gen.Stop}

\**\VarIniWait.Set=
>{Const Lex.ReceiverMkSet=Root.FindAnd
  MnemoTable.LineCopyAddPrevLoadSet={Var}
  FUListNew.ReceivedLoadOutMk=MnemoTable.LastLoadSet
  MnemoTable.LastLoadConstVarTypeSet=0
  MnemoTable.LastPopMk
  Console.OutLn="VarIniWait Const"
  //MnemoTable.OutMk=Console.OutLn
}
//>{Mnemo Lex.ReceiverMkSet=VarIniWait2.FindAnd}
>{Vect Lex.ReceiverMkSet=Root.FindAnd
FUListNew.ReceivedOutMk=MnemoTable.LastAttach}
>{Sep="[" Lex.ReceiverMkSet=VectWait.FindAnd
  FUALUNew.VectNew
  MnemoTable.LineCopyAddPrevLoadSet={Vect}
    Console.OutLn="Vect ini"
  FUALUNew.OutMk=Console.OutLn
  FUALUNew.OutMk=MnemoTable.LastLoadSet
//  MnemoTable.LastLoadConstVarTypeSet // Установить тип "переменная" для нагрузки
  MnemoTable.LastPopMk
}
>{0 Console.OutLn="Variable inisialization error" Lex.Stop FUListNew.ReceivedCopyOutMk=Console.OutLn}

\**\EqualWait.Set=
>{Sep="=" Lex.ReceiverMkSet=EqualAfter.FindAnd Console.OutLn="EqualWait ="}
>{Sep="}" Lex.ReceiverMkSet=Root.FindAnd
  Root.FindAnd={Sep="}"} // Перейти в корневое состояние для проверки на '}'
}
>{0 Lex.ReceiverMkSet=Root.FindAnd
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}

\**\EqualAfter.Set= \* 10.03.2023 *\
>{FU
  Lex.ReceiverPush=MkAutom.FindAnd 
Console.OutLn="FU2"
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}
>{Sep="." Lex.ReceiverPush=MkAutom.FindAnd
  Stack.FindAndLast={MkBrack}
  Stack.FailExec={Lex.Stop Console.OutLn="Fu name is expected" ProgStopAll}
  Stack.LastLoadOut=t Lex.SendToReceiver={FU=t(nil)!}
  Lex.SendToReceiver={Sep="."}
}
>{Vect
Console.OutLn="ALECheck Vect"
  Lex.ReceiverMkSet=Root.FindAnd
  Lex.ReceiverPush=EqAleAfter.FindAnd

  Root.ReceivedOutMk=Stack.LineCopyAdd
  Stack.FindAndLast={Mk}
  Stack.FailExec={Lex.Stop ALECheck.ProgStopAll Console.OutLn="Mk is required"}
  Stack.LastDelMk

  OAList.LastAtrSet=FUALUNew.ProgExec
  OAList.LineCopyAddPrevLoadSet={FUALUNew.OutMkAppend}
  Root.ReceivedLoadOutMk=OAList.LastLoadSet	

  OAList.LastAttach={FUALUNew.Set}
  OpPriority.FindAnd={Sep="="} // ????? ??????? ??????????? ?? ??????????

  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}
>{Sep="(" Sep="-" Mnemo="tern" Func Func1Arg FuncALE FuncALE1Arg Lex.ReceiverMkSet=Root.FindAnd // АЛВ в нагрузке МК
Console.OutLn="EqualAfter ("
  Root.ReceivedOutMk=Stack.LineCopyAdd
  Stack.FindAndLast={Mk}
  Stack.FailExec={Lex.Stop EqualAfter.ProgStopAll Console.OutLn="Mk is required"}
  Stack.LastDelMk

  OAList.LastAtrSet=FUALUNew.ProgExec
  OAList.LineCopyAddPrevLoadSet={FUALUNew.OutMkAppend}
  Root.ReceivedLoadOutMk=OAList.LastLoadSet	
  Lex.ReceiverPush=EqAfter.FindAnd
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}
>{Const Var Vect\* 10.03.2023 *\
  Console.OutLn="EqualAfter Const Var"
  Lex.ReceiverMkSet=ALECheck.FindAnd
}
>{Atr Lex.ReceiverMkSet=Root.FindAnd \* 25.03.2023 *\
FUListNew.ReceivedLoadOutMk=MnemoTable.LineCopyAddPrevLoadSet
MnemoTable.LastPopMk}
>{Mk Lex.ReceiverMkSet=LoadAfter.FindAnd}
>{Mnemo Lex.ReceiverMkSet=MnemoLoad.FindAnd
  FUListNew.ReceivedOutMk=MnemoTable.LineCopyAdd
  MnemoTable.LastAttach={Lex.SendToReceiver}
  Console.OutLn="EqualAfter Mnemo"
}
>{Sep="{" Lex.ReceiverMkSet=Root.FindAnd
  Console.OutLn="={ !"
 // OAList.OutMk=Console.OutLn
  Console.OutLn="`````````"
  OAList.LineCopyAddPrevLoadSet // ?????????? ?????? ??????
//  OAList.OutMk=Console.OutLn
//  OAList.PushTiedLineCopy // ?????????? ?? ??????? ???? ? ??-?????
  Stack.LineAdd={Sep="{"}
  Console.OutLn="Stack:"
  Stack.OutMk=Console.OutLn
  Console.OutLn="`````````"
 }
>{Sep=">" Lex.ReceiverMkSet=ListAfter.FindAnd
  OAList.PushTied
  Stack.LineAdd={Sep=">"}
Console.OutLn="= >"
OAList.RootOutMk=Console.OutLn
Console.OutLn="= >"}
>{Sep="<" Lex.ReceiverMkSet=ListAfter.FindAnd}
//  OAList.OutMk=Console.OutLn
>{Mnemo Lex.ReceiverMkSet=BackRecLoad.FindAnd} \* 10.03.2023 *\
>{IC Lex.ReceiverMkSet=Root.FindAnd} \* 10.03.2023 *\
>{IP Lex.ReceiverMkSet=Root.FindAnd} \* 10.03.2023 *\
>{0 Lex.Stop Console.OutLn="Mk or Var is expected"}

\**\LoadAfter.Set=
>{Sep="=" Lex.ReceiverMkSet=EqualAfter.FindAnd
  MkCalc.OutMk=OAList.LastAtrAttach
  BackCloneCounter.Inc
Console.OutLn="LoadAfter ="
}
//>{Sep="," Lex.ReceiverMkSet=EqualAfter.FindAnd}
>{0 Lex.ReceiverMkSet=Root.FindAnd
  MkCalc.OutMk=OAList.LastLoadSet
  Console.Out="BackClone " BackCloneCounter.OutMk=Console.OutLn
  BackCloneCounter.OutMk=OAList.LastLoadBackSet // Клонирование нагрузок ИП
  BackCloneCounter.Set=0
  FUListNew.ReceivedOutMk=Root.FindAnd
Console.OutLn="LoadAfter else"}

\**\MnemoLoad.Set= \* 10.03.2023 *\
>{Sep="{" Lex.ReceiverMkSet=Root.FindAnd
  OAList.LineAdd
  OAList.LineCopyAddPrevLoadSet
  MnemoTable.LineCopyAddPrevLoadSet={IC}
  OAList.LastOutMk=MnemoTable.LastLoadSet
  MnemoTable.LastPopMk
  Stack.LineCopyAdd={Sep="{"}
Console.OutLn="=Name{"
  }
>{Sep=">" Lex.ReceiverMkSet=ListAfter.FindAnd
  Stack.LineAdd={Sep=">"}
  OAList.PushTiedCopy
  MnemoTable.LineCopyAddPrevLoadSet={IC}
  OAList.OutMk=MnemoTable.LastLoadSet
  Console.OutLn="Mnemo >"
//  OAList.OutMk=Console.OutLn
  MnemoTable.LastPopMk
}
>{Sep="<" Lex.ReceiverMkSet=ListAfter.FindAnd}
>{Sep="(" Lex.ReceiverMkSet=LoadVar.FindAnd
  Stack.LineCopyAdd={MnemoLoadBrack}
  Console.OutLn="LoadVar"
}
>{0 Lex.ReceiverMkSet=Root.FindAnd
  MnemoTable.LineCopyAddPrevLoadSet={BackVar}
  OAList.LastLoadRefOutMk=MnemoTable.LastLoadSet}


\**\ListAfter.Set=
>{Sep="{" Lex.ReceiverMkSet=Root.FindAnd
  Stack.LineAdd={Sep="{"}
OAList.LineAdd
Console.OutLn="ListBefore >{"
//OAList.OutMk=Console.OutLn
OAList.LineCopyAddPrevSet
Console.OutLn="ListAfter >{"
OAList.RootOutMk=Console.OutLn
  }
>{Const Atr Var Lex.ReceiverMkSet=Root.FindAnd
  FUListNew.LoadOutMk=OAList.LastLoadSet}
>{Sep="{"  Lex.ReceiverMkSet=Root.FindAnd
  Stack.LineAdd={Sep="{"}
  OAList.PushTiedCopy
  }
>{Mk Lex.ReceiverMkSet=Root.FindAnd} \* 5.03.2023 *\
>{Mnemo Lex.ReceiverMkSet=ListAfterMnemo.FindAnd
  FUListNew.ReceivedOutMk=MnemoTable.LineCopyAdd
  MnemoTable.LastAttach={Lex.SendToReceiver}
}
>{Sep=">" Lex.ReceiverMkSet=ListAfter.FindAnd} \* 05.03.2023 *\
>{Sep="<" Lex.ReceiverMkSet=ListAfter.FindAnd} \* 05.03.2023 *\

\**\ListAfterMnemo.Set=
>{Sep="{" Lex.ReceiverMkSet=Root.FindAnd
  Stack.LineAdd={Sep="{"}
  MnemoTable.LineCopyAddPrevLoadSet={IC}
  OAList.LineAdd
  OAList.LineCopyAddPrevSet
  OAList.LastOutMk=MnemoTable.LastLoadSet
  MnemoTable.LastPopMk
}
>{0 Console.OutLn="Wrong mnemonics description" Lex.Stop}

\**\LoadVar.Set=
>{FU
//  Prog=ListCheckProg

  Lex.ReceiverPush=LoadVarFU.FindAnd

Console.OutLn="FU3"
}
>{Sep="." Lex.ReceiverPush=MkAutom.FindAnd
      Stack.FindAndLast={MkBrack}
     Stack.FailExec={Lex.Stop Console.OutLn="Fu name is expected" ProgStopAll}
     Stack.LastLoadOut=t Lex.SendToReceiver={FU=t(nil)!}
	Lex.SendToReceiver={Sep="."}
}
>{Mk Atr Lex.ReceiverMkSet=LoadMnemoBack.FindAnd
  Prog=ListCheckProg
  FUListNew.ReceivedLoadOutMk=OAList.LastLoadSet
  MnemoTable.LineCopyAddPrevLoadSet={Var}
Console.OutLn="FUAfter3 fin"
  OAList.LastLoadOutMk=MnemoTable.LastLoadSet
  MnemoTable.LastPopMk
}
>{Const Lex.ReceiverMkSet=ALECheck2.FindAnd \* 10.03.2023 *\
  FUListNew.ReceivedOutMk=MnemoTable.LastAttach
 MnemoTable.LastLoadConstVarTypeSet
}
>{Var Lex.ReceiverMkSet=ALECheck2.FindAnd} \* 10.03.2023 *\
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
>{Sep="(" \* 22.03.2023 *\
  Lex.ReceiverMkSet=ALEAfter.FindAnd
  Lex.ReceiverPush=EqAleAfter.FindAnd
  FUListNew.ReceivedOutMk=Lex.SendToReceiver}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
>{0 Console.OutLn="Var or Const is expected" Lex.Stop}

LoadVarFU.Set=
>{Sep="."
  Lex.ReceiverPush=MkAutom.FindAnd
  LoadVar.ReceivedOutMk=Lex.SendToReceiver
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}
>{Mk Atr Lex.ReceiverMkSet=LoadMnemoBack.FindAnd
  Prog=ListCheckProg
  FUListNew.ReceivedLoadOutMk=OAList.LastLoadSet
  MnemoTable.LineCopyAddPrevLoadSet={Var}
Console.OutLn="FUAfter3 fin"
  OAList.LastLoadOutMk=MnemoTable.LastLoadSet
  MnemoTable.LastPopMk
}
>{0 Console.OutLn="Mk is expected" Lex.Stop}

\**\VectWait.Set= \* 05.03.2023 *\
>{Const Var Vect Lex.ReceiverMkSet=VectNext.FindAnd
  FUListNew.ReceivedLoadOutMk=FUALUNew.Append \* 24.03.2023 *\
  Console.OutLn="Element was added in the vector !"
  FUListNew.ReceivedLoadOutMk=Console.OutLn}
>{Sep="]" Lex.ReceiverMkSet=Root.FindAnd
  FUALUNew.PopMk}
>{0 Lex.Stop Console.OutLn="Wrong vector description"}

\**\VectNext.Set= \* 05.03.2023 *\
>{Sep = "," Lex.ReceiverMkSet=VectNext2.FindAnd
//  FUListNew.ReceivedLoadOutMk=FUALUNew.Append \* 19.03.2023 *\
  Console.OutLn="Index of the vector was increased"}
>{Sep="]" Lex.ReceiverMkSet=Root.FindAnd
//  FUALUNew.PopMk
}
>{Const Var Vect Lex.ReceiverMkSet=VectNext.FindAnd
  FUListNew.ReceivedLoadOutMk=FUALUNew.Append \* 24.03.2023 *\
  Console.OutLn="Element was added in the vector"}
>{0 Lex.Stop Console.OutLn="',' or ']' is expected"}

\**\VectNext2.Set= \* 19.03.2023 *\
>{Const Var Vect Lex.ReceiverMkSet=VectNext.FindAnd
  FUListNew.ReceivedLoadOutMk=FUALUNew.Append \* 24.03.2023 *\
  Console.OutLn="Element was added in the vector"}
>{0 Lex.Stop Console.OutLn="Wrong vector description"}

\**\BackRecLoad.Set= \* 05.03.2023 *\
>{Sep="(" Lex.ReceiverMkSet=BackRecAtrWait.FindAnd}
>{Sep="{" Lex.ReceiverMkSet=Root.FindAnd}
>{Sep="}" Lex.ReceiverMkSet=Root.FindAnd}
>{0 Lex.ReceiverMkSet=Root.FindAnd}

\**\BackRecAtrWait.Set= \* 05.03.2023 *\
>{Atr Lex.ReceiverMkSet=BackRecBrackWait.FindAnd}
>{Sep=")" Lex.ReceiverMkSet=Root.FindAnd}
>{0 Lex.Stop Console.OutLn="BackRec atribute or close bracket was expected"}

\**\BackRecBrackWait.Set= \* 05.03.2023 *\
>{Sep=")" Lex.ReceiverMkSet=Root.FindAnd}
>{0 Lex.Stop Console.OutLn="BackRec close bracket was expected"}

\**\AtrRefLoad.Set= \* 05.03.2023 *\
>{Sep="[" Lex.ReceiverMkSet=AtrRefWait.FindAnd}
>{0 Lex.Stop Console.OutLn="BackRec load was expected"}

\**\AtrRefWait.Set= \* 05.03.2023 *\
>{Atr Lex.ReceiverMkSet=AtrRefBrackWait.FindAnd}
>{0 Lex.Stop Console.OutLn="Atribute reference was expected"}

\**\AtrRefBrackWait.Set= \* 05.03.2023 *\
>{Sep="]" Lex.ReceiverMkSet=MkBrackWait.FindAnd}
>{0 Lex.Stop Console.OutLn="Atribute reference close bracket was expected"}

\**\MkBrackWait.Set= \* 05.03.2023 *\
>{Sep="(" Lex.ReceiverMkSet=Root.FindAnd}
>{0 Lex.Stop Console.OutLn="Mk open bracket was expected"}

\**\ALECheck.Set= \* 23.03.2023 *\
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
>{Sep="=" Sep="+" Sep="-" Sep="*" Sep="/" 
  Sep="//" Sep="%" Sep="**" Sep="&" Sep="&&" 
  Sep="|" Sep="||" Sep="^" Sep="^^" \* 22.03.2023 *\
Console.OutLn="ALECheck Operatin"
  Lex.ReceiverMkSet=Root.FindAnd
  Lex.ReceiverPush=EqAleAfter.FindAnd

  Root.ReceivedOutMk=Stack.LineCopyAdd
  Stack.FindAndLast={Mk}
  Stack.FailExec={Lex.Stop ALECheck.ProgStopAll Console.OutLn="Mk is required"}
  Stack.LastDelMk

  OAList.LastAtrSet=FUALUNew.ProgExec
  OAList.LineCopyAddPrevLoadSet={FUALUNew.OutMkAppend}
  Root.ReceivedLoadOutMk=OAList.LastLoadSet	

  OAList.LastAttach={FUALUNew.Set}
  OpPriority.FindAnd={Sep="="} // Сброс таблицы приоритетов АЛ операторов

  EqualAfter.ReceivedOutMk=Lex.SendToReceiver
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//>{Sep=">>" Sep="<<" Lex.ReceiverMkSet=ALE.FindAnd} \* 16.03.2023 *\ 
>{0
  Console.OutLn="ALECheck else"
  Lex.ReceiverMkSet=Root.FindAnd
  EqualAfter.ReceivedLoadOutMk=OAList.LastLoadSet
//OAList.OutMk=Console.OutLn
//FUListNew.ReceivedOutMk=Console.OutLn
  FUListNew.ReceivedOutMk=Lex.SendToReceiver}

\**\ALECheck2.Set= \* 10.03.2023 *\
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
>{Sep="=" Sep="+" Sep="-" Sep="*" Sep="/" 
  Sep="//" Sep="%" Sep="**" Sep="&" Sep="&&" 
  Sep="|" Sep="||" Sep="^" Sep="^^" \* 22.03.2023 *\
	Lex.ReceiverMkSet=ALEAfter.FindAnd
	Lex.ReceiverPush=LoadVar.FindAnd
	EqualAfter.ReceivedLoadOutMk=Lex.SendToReceiver
     FUListNew.ReceivedOutMk=Lex.SendToReceiver
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////
//>{Sep=">>" Sep="<<" Lex.ReceiverMkSet=ALE.FindAnd} \* 16.03.2023 *\
>{0
  Console.OutLn="ALECheck else"
  Lex.ReceiverMkSet=Root.FindAnd
 EqualAfter.ReceivedOutMk=Console.OutLn
  EqualAfter.ReceivedLoadOutMk=OAList.LastLoadSet
  FUListNew.ReceivedOutMk=Lex.SendToReceiver}

// ---- ALE ----

\* 23.03.2023 *\
OpPriority.MkModeSet=0 // Turning off mk execution
\**\OpPriority.Set= 
>{FUALUNew.Set}
>{Sep="*" Sep="/" Sep="//" Sep="%" FUALUNew.Mul FUALUNew.Div FUALUNew.DivInt FUALUNew.Remainder}
>{Sep="+" Sep="-" FUALUNew.Sum FUALUNew.Sub}
>{Sep="<-" Sep="->" FUALUNew.MrBit FUALUNew.MlBit}
>{Sep="==" Sep="<>" Sep="<=>" Sep="<" Sep="<=" Sep=">" Sep=">="
FUALUNew.Smaller FUALUNew.SmallerEQ FUALUNew.Bigger FUALUNew.BiggerEQ FUALUNew.EQ FUALUNew.NotEQ}
>{Sep="&" FUALUNew.AndBit}
>{Sep="^" FUALUNew.XorBit}
>{Sep="|" FUALUNew.Or}
>{Sep="&&" FUALUNew.AndBit}
>{Sep="||" FUALUNew.OrBit}
>{Sep="="}


\**\ALE.Set=
>{Var Lex.ReceiverMkSet=VarAfter.FindAnd
  OAList.LastAttach={FUALUNew.OutAdrAppend}
  FUListNew.ReceivedLoadOutMk=OAList.LastLoadSet
  Console.OutLn="ALE Var"
}
>{Mk Lex.ReceiverMkSet=EqAleWait.FindAnd \* 05.03.2023 *\ 
  OAList.LastAttach={FUALUNew.OutMkAppend}
  FUListNew.ReceivedLoadOutMk=OAList.LastLoadSet
}
>{Vect Lex.ReceiverMkSet=VectAfter.FindAnd} \* 05.03.2023 *\
>{0 Lex.ReceiverMkSet=Root.FindAnd} \* 05.03.2023 *\ 
//>{0 Lex.ReceiverMkSet=ALEAfter.FindAnd} \* 10.03.2023 *\ \* если после ALECheck2 || LoadVar *\ 
// >{Vect Lex.ReceiverMkSet=VectAfter.FindAnd}

\**\AccumEqwList.Set= \* 17.03.2023 *\
>{Sep="+=" OAList.LastAtrAttach=FUALUNew.Sum}
>{Sep="-=" OAList.LastAtrAttach=FUALUNew.Sub}
>{Sep="*=" OAList.LastAtrAttach=FUALUNew.Mul}
>{Sep="/=" OAList.LastAtrAttach=FUALUNew.Div}
>{Sep="//=" OAList.LastAtrAttach=FUALUNew.DivInt}
>{Sep="%=" OAList.LastAtrAttach=FUALUNew.Remainder}
>{Sep="**=" OAList.LastAtrAttach=FUALUNew.Pow}
>{Sep="->=" OAList.LastAtrAttach=FUALUNew.MlBit}
>{Sep="<-=" OAList.LastAtrAttach=FUALUNew.MrBit}
>{Sep="&=" OAList.LastAtrAttach=FUALUNew.And}
>{Sep="&&=" OAList.LastAtrAttach=FUALUNew.AndBit}
>{Sep="|="  OAList.LastAtrAttach=FUALUNew.Or}
>{Sep="||=" OAList.LastAtrAttach=FUALUNew.OrBit}
>{Sep="^="  OAList.LastAtrAttach=FUALUNew.Xor}
>{Sep="^^=" OAList.LastAtrAttach=FUALUNew.XorBit}

\**\VarAfter.Set=
>{Sep="," Lex.ReceiverMkSet=EqAleWait3.FindAnd} \* 05.03.2023 *\ 
>{Sep="=" Lex.ReceiverMkSet=EqAfter.FindAnd Console.OutLn="ALEAfter ="}
>{Sep="++" Console.OutLn="++" Stack.LastAttach={FUALUNew.Sum=1} Stack.LastOutMk=FUALUNew.Calc \* 22.03.2023 *\ 
  Lex.ReceiverPopSend 
  Lex.ReceiverMkSet=End.FindAnd} 
>{Sep="--" Console.OutLn="--" Stack.LastAttach={FUALUNew.Sub=1} Stack.LastOutMk=FUALUNew.Calc \* 22.03.2023 *\
  Lex.ReceiverPopSend 
  Lex.ReceiverMkSet=End.FindAnd} 
>{Sep="+=" Sep="-=" Sep="*=" Sep="/="  \* 16.03.2023 *\
    Sep="//=" Sep="%="
  Lex.ReceiverMkSet=EqAleAfter.FindAnd 
  OAList.LastAtrAttach=FUALUNew.Set
  ALE.ReceivedLoadOutMk=OAList.LastLoadSet
  FUListNew.ReceivedOutMk=AccumEqwList.FindAnd // Передать лексему на разбор в AccumEqwList
  OAList.LineCopyAddPrevLoadSet
  Stack.LineCopyAdd={AleStackUp}
}
>{0
Console.OutLn="VarAfter else" 
//  ALE.ReceivedLoadOutMk=Console.OutLn  
//  ALE.ReceivedLoadOut=temp OAList.LastAttach={FUALUNew.AnsOut=temp(nil)!}
//  Lex.ReceiverPop
//  FUListNew.ReceivedOutMk=Lex.SendToReceiver
//Console.OutLn="VarAfter else"
  Lex.Stop Console.OutLn="Assignment/Accum assignment/Increment/Decrement were expected"
}

\**\VectAfter.Set=
>{Sep="[" Lex.ReceiverMkSet=EqAleAfter.FindAnd}
>{Sep="++" Console.OutLn="++" Stack.LastAttach={FUALUNew.Sum=1} Stack.LastOutMk=FUALUNew.Calc \* 22.03.2023 *\ 
  Lex.ReceiverPopSend 
  Lex.ReceiverMkSet=End.FindAnd} 
>{Sep="--" Console.OutLn="--" Stack.LastAttach={FUALUNew.Sub=1} Stack.LastOutMk=FUALUNew.Calc \* 22.03.2023 *\
  Lex.ReceiverPopSend 
  Lex.ReceiverMkSet=End.FindAnd}
>{0 Lex.Stop Console.OutLn="Vector open bracket was expected"}

\**\VectAleAfter.Set=
>{Sep="[" Sep="=" Sep="+" Sep="-" Sep="*" 
Sep="/" Sep="//" Sep="%" Sep="**" Sep="&" 
Sep="&&" Sep="|" Sep="||" Sep="^" Sep="^^" 
Lex.ReceiverMkSet=EqAleAfter.FindAnd} \* 16.03.2023 *\ 
//>{Sep=">>" Sep="<<" Lex.ReceiverMkSet=EgAleAfter.FindAnd} \* 16.03.2023 *\
>{Sep="[" Lex.ReceiverMkSet=EqAleAfter.FindAnd}
>{0 Lex.Stop Console.OutLn="Vector open bracket or operator were expected"}

\**\VectAleWait.Set=
>{Sep="[" Lex.ReceiverMkSet=VectAleAfter.FindAnd}
>{Sep="+" Sep="-" Sep="*" Sep="/" Sep="//" Sep="%" Sep="**" Sep="->" Sep="->"
  Sep="&" Sep="&&" Sep="|" Sep="||" Sep="^" Sep="^^"
  Lex.ReceiverMkSet=OperatWait.FindAnd
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
Console.OutLn="ALE Vect Operatipon"
}
>{0 Lex.Stop Console.OutLn="Wrong vector descreabing"}

\**\VectAleAfter.Set=
>{Var Const Lex.ReceiverMkSet=VectAleAfter2.FindAnd}
>{0 Lex.ReceiverMkSet=EqAleAfter.FindAnd
  OpPriority.FindAnd={Sep="="} // Сброс приоритетов операций
  Stack.LineCopyAdd={Sep="["}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}

\**\VectAleAfter2.Set=
>{Sep="]" Lex.ReceiverMkSet=OperatWait.FindAnd
  VectAleAfter.ReceivedLoadOutMk=OAList.LastIndSet
Console.OutLn="LastIndSet"
//FUALUNew.PopMk
FUALUNew.Set=0
//OAList.OutMk=Console.OutLn
}
>{0 
  OpPriority.FindAnd={Sep="="} // Сброс приоритетов операций
  Stack.LineCopyAdd={Sep="["}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
  VectAleAfter.ReceivedOutMk=Lex.SendToReceiver
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}

\**\EqAleAfter.Set=
>{Vect Lex.ReceiverMkSet=VectAleWait.FindAnd \* 05.03.2023 *\
  FUListNew.ReceivedLoadOutMk=OAList.LastLoadSet
Console.OutLn="EqAleAfter Vect"
}
>{Var Const Lex.ReceiverMkSet=OperatWait.FindAnd \* 05.03.2023 *\
  FUListNew.ReceivedLoadOutMk=OAList.LastLoadSet
Console.OutLn="EqAleAfter Var Const"
//  OAList.OutMk=Console.OutLn
}
>{Mnemo="tern" Lex.ReceiverMkSet=EqAleAfter.FindAnd
  Stack.LineCopyAdd={AleSep="tern"}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
}
>{Sep="-" Lex.ReceiverMkSet=EqAleAfter.FindAnd
  Stack.LineAdd={Sep="=" Sep="(" Sep="==" Sep="!=" Sep="<" Sep=">" Sep="<=" Sep=">=" // Проверка на разделители, после которых может стоять знак "-"
    Sep="|" Sep="&" Sep="^"}
Console.OutLn="EqAleAfter -"
  Lex.PrevOutMk=Stack.FindAnd
  Stack.FailExec={Lex.Stop EqAleAfter.ProgStopAll Console.OutLn="Operand is expected" Stack.LastPopMk}
  Stack.LastPopMk
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set=0}
  OAList.LastAttach={FUALUNew.Sub}
  Stack.LineCopyAdd={AleStackUp}
}
>{Sep="(" Lex.ReceiverMkSet=EqAleAfter.FindAnd
  Stack.LineCopyAdd={AleSep="("}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
}
>{Sep="[" Lex.ReceiverMkSet=EqAleAfter.FindAnd \*07.04.2023*\
  Stack.LineCopyAdd={Sep="["}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.VectNew FUALUNew.Append}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
}
>{Func Lex.ReceiverMkSet=FuncAfter.FindAnd \* 07.04.2023 *\
  Stack.LineCopyAdd={Func}
 Console.OutLn="Func"
}
>{FuncALE Lex.ReceiverMkSet=FuncAfter.FindAnd \* 07.04.2023 *\
 Stack.LineCopyAdd={FuncALE}

 OAList.LineCopyAddPrevLoadSet
 EqAleAfter.ReceivedLoadOutMk=OAList.LastAtrAttach
 OAList.LineCopyAddPrevLoadSet={FUALUNew.VectNew}
 OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
	Console.OutLn="FuncALE Set"
}
>{FuncALE1Arg Lex.ReceiverMkSet=FuncALE1ArgAfter.FindAnd
 OAList.LineCopyAddPrevLoadSet
 EqAleAfter.ReceivedLoadOutMk=OAList.LastAtrAttach
	Console.OutLn="EqAleAfter ALEFunc1Arg"
} \* 07.04.2023 *\
>{Func1Arg Lex.ReceiverMkSet=Func1ArgAfter.FindAnd
	Console.OutLn="Func1Arg"
} \* 07.04.2023 *\
>{0 Lex.Stop Console.OutLn="Var/Const/Vector Open ariphmetic bracket were expected"
	FUListNew.ReceivedOutMk=Console.OutLn
}

\**\FuncALEAfter.Set=
>{Sep="(" Lex.ReceiverMkSet=EqAleAfter.FindAnd

}

\**\FuncALE1ArgAfter.Set=
>{Sep="(" Lex.ReceiverMkSet=EqAleAfter.FindAnd
     OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
	Stack.LineCopyAdd={FuncALE1Arg}
}
>{Sep="[" Lex.ReceiverMkSet=EqAleAfter.FindAnd
  Stack.LineCopyAdd={FuncALE1Arg}
  Stack.LineCopyAdd={Sep="["}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.VectNew FUALUNew.Append}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
}
>{Var Const Vect Lex.ReceiverMkSet=OperatWait.FindAnd // Прописать один аргумент
Console.OutLn="Func1ArgAfter Var Const Vect" 
 FUListNew.ReceivedLoadOutMk=OAList.LastLoadSet
 OAList.LastPopMk 
}
>{0 Lex.Stop Console.OutLn="Wrong function description"}

\**\FuncAfter.Set=
>{Sep="(" Lex.ReceiverMkSet=EqAleAfter.FindAnd
//  Stack.LineCopyAdd={Func}
}
//>{Var Lex.ReceiverMkSet=OperatWait.FindAnd} 
//>{Const Lex.ReceiverMkSet=OperatWait.FindAnd}
//>{Vect Lex.ReceiverMkSet=OperatWait.FindAnd}\*
>{0 Lex.Stop Console.OutLn="Var/Const/Vector/Open ariphmetic bracket were expected"}

\**\OpPriority.Set= // Приоритет АЛ операций
>{Sep="==" Sep="!=" Sep="<" Sep="<=" Sep=">" Sep=">="
  FUALUNew.EQ FUALUNew.NotEQ FUALUNew.Smaller FUALUNew.SmallerEQ FUALUNew.Bigger FUALUNew.BiggerEQ}
>{Sep="|" Sep="^" Sep="&" FUALUNew.Or FUALUNew.Xor FUALUNew.And}
>{Sep="+" Sep="-" FUALUNew.Sum FUALUNew.Sub}
>{Sep="*" Sep="/" Sep="//" FUALUNew.Mul FUALUNew.Div FUALUNew.DivInt}
>{Sep="%" Sep="**" FUALUNew.Remainder FUALUNew.Pow}
>{Sep="<-" Sep="->" FUALUNew.MlBit FUALUNew.MrBit}
>{Sep="||" Sep="^^" Sep="&&" FUALUNew.OrBit FUALUNew.XorBit FUALUNew.AndBit}
>{Sep="="} // Для сбороса приоритетов АЛ операций

\**\OpTranslate.Set= // Таблица трансляции оперторов
//>{Sep="=" Lex.ReceiverMkSet=EqAleAfter.FindAnd}
>{Sep="+" OAList.LastAtrAttach=FUALUNew.Sum}
>{Sep="-" OAList.LastAtrAttach=FUALUNew.Sub}
>{Sep="*" OAList.LastAtrAttach=FUALUNew.Mul}
>{Sep="/" OAList.LastAtrAttach=FUALUNew.Div}
>{Sep="//" OAList.LastAtrAttach=FUALUNew.DivInt}
>{Sep="%" OAList.LastAtrAttach=FUALUNew.Remainder}
>{Sep="**" OAList.LastAtrAttach=FUALUNew.Pow}
>{Sep="<-" OAList.LastAtrAttach=FUALUNew.MlBit}
>{Sep="->" OAList.LastAtrAttach=FUALUNew.MrBit}
>{Sep="&"  OAList.LastAtrAttach=FUALUNew.And}
>{Sep="&&" OAList.LastAtrAttach=FUALUNew.AndBit}
>{Sep="|"  OAList.LastAtrAttach=FUALUNew.Or}
>{Sep="||" OAList.LastAtrAttach=FUALUNew.OrBit}
>{Sep="^"  OAList.LastAtrAttach=FUALUNew.Xor}
>{Sep="^^" OAList.LastAtrAttach=FUALUNew.XorBit}
>{Sep="<" OAList.LastAtrAttach=FUALUNew.Smaller}
>{Sep=">" OAList.LastAtrAttach=FUALUNew.Bigger}
>{Sep="<=" OAList.LastAtrAttach=FUALUNew.SmallerEQ}
>{Sep=">=" OAList.LastAtrAttach=FUALUNew.BiggerEQ}


\**\OperatWait.Set= \* 17.03.2023 *\
>{Sep=")" Lex.ReceiverMkSet=OperatWait.FindAnd \* 02.04.2023 *\

  Stack.FindAndLast={AleStackUp}
  Stack.SuccessExec=AleStackUpDel{ // Удаление приоритетов операций
    FUListNew.LastDelMk
    OAList.LastPopMk
    FUListNew.FindAndLast={AleStackUp}
    FUListNew.SuccessExec=AleStackUpDel
  }

  Stack.FindAndLast={FuncALE1Arg}
  Stack.SuccessExec={ // Обработка закрывающейся скобки у одноаргументной функции
Console.OutLn="OperatWait FuncALE1Arg )"  
  Stack.LastDelMk
  OAList.LastPopMk
  OAList.LastPopMk
  OpPriority.FindAnd={Sep="="} // Сбросить таблицу приоритетов операций
  OperatWait.ProgStopAll
  }

  Stack.FindAndLast={FuncALE}
  Stack.SuccessExec={ // Обработка закрывающейся скобки у одноаргументной ФУ ФЛУ функции
Console.OutLn="OperatWait FuncALE )"  
  Stack.LastDelMk
  OAList.LastPopMk
  OAList.LastPopMk
  OAList.LastPopMk
  OpPriority.FindAnd={Sep="="} // Сбросить таблицу приоритетов операций
//OAList.OutMk=Console.OutLn
  OperatWait.ProgStopAll
  }

  FUListNew.ReceivedOutMk=Console.OutLn 

  OAList.LastIpOutMk=OpPriority.FindAnd
  Stack.FindAndLast={AleSep="("}
  Stack.FailExec={Lex.Stop Console.OutLn="'(' is missing"}
  Stack.LastDelMk
  OAList.LastPopMk
  OAList.LastIpOutMk=OpPriority.FindAnd // Сброс приоритетов
Console.OutLn="ALE )"
//OAList.OutMk=Console.OutLn
FUListNew.ReceivedOutMk=Console.OutLn
}
>{Sep="]" Lex.ReceiverMkSet=OperatWait.FindAnd
  Stack.FindAndLast={AleStackUp}
  Stack.SuccessExec=AleStackUpDel // Удаление приоритетов операций
  Stack.LastDelMk
  OAList.LastPopMk
}
>{Sep="{" Lex.ReceiverMkSet=EqAleAfter.FindAnd  \* 01.04.2023 *\
  Stack.FindAndLast={AleStackUp}
  Stack.SuccessExec=AleStackUpDel // Удаление приоритетов операций
  Stack.FindAndLast={AleSep="tern"}
  // Ошибка оформления тернарной конструкции
  Stack.FailExec={
//Lex.Stop Console.OutLn="Ternar construction wrong description" 
    ProgExec=AleFinProg
    OperatWait.ProgStopAll}
  OAList.LastAttach={FUALUNew.TernarYes}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
  Stack.LastPopMk
  Stack.LineCopyAdd={AleSep="{"}
}  
>{Mnemo="else" Lex.ReceiverMkSet=EqAleAfter.FindAnd  \* 01.04.2023 *\
  Stack.FindAndLast={AleStackUp}
  Stack.SuccessExec=AleStackUpDel // Удаление приоритетов операций
  Stack.FindAndLast={AleSep="{"}
  // Ошибка оформления тернарной конструкции
  Stack.FailExec={Lex.Stop Console.OutLn="Ternar construction wrong description" ProgStopAll}
  OAList.LastPopMk
  OAList.LastAttach={FUALUNew.TernarNo}
  OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
  Stack.LastDelMk
  Stack.LineCopyAdd={AleSep="else"}
}
>{Sep="}" Lex.ReceiverMkSet=OperatWait.FindAnd  \* 01.04.2023 *\
  Stack.FindAndLast={AleStackUp}
  Stack.SuccessExec=AleStackUpDel // Удаление приоритетов операций
  Stack.FindOrLast={AleSep="else"}
  // Ошибка оформления тернарной конструкции
//  Stack.FailExec={Lex.Stop Console.OutLn="Ternar construction wrong description" ProgStopAll}
  Stack.FailExec={ProgExec=AleFinProg OperatWait.ProgStopAll Console.OutLn="OperatWait }" OAList.LastPopMk}
  Stack.LastDelMk
  OAList.LastPopMk
  OAList.LastPopMk
}  

>{Sep=","  Lex.ReceiverMkSet=EqAleAfter.FindAnd
Console.OutLn="OperatWait ,"
// Stack.OutMk=Console.OutLn
  Stack.FindAndLast={AleStackUp}
  Stack.SuccessExec=AleStackUpDel! // Удаление приоритетов операций
  Stack.FindAndLast={FuncALE}
  Stack.SuccessExec={
    OAList.LastPopMk
    OAList.LastAttach={FUALUNew.Append}
    OAList.LineCopyAddPrevLoadSet={FUALUNew.Set}
Console.OutLn="FuncALE ,"
//OAList.OutMk=Console.OutLn
  }
}
>{Sep="+" Sep="-" Sep="*" Sep="/" Sep="//" Sep="%" Sep="**" Sep="->" Sep="->"
  Sep="&" Sep="&&" Sep="|" Sep="||" Sep="^" Sep="^^" Sep="<" Sep=">" Sep="<=" Sep=">=" 
Console.OutLn="ALE Operatipon"
  Lex.ReceiverMkSet=EqAleAfter.FindAnd
  FUListNew.ReceivedOutMk=OpPriority.FindAnd
  OpPriority.BiggerExec={ // Обработка операции с высоким приоритетом
    OAList.LastLoadOut=t
    OAList.LineCopyAddPrevLoadSet={FUALUNew.Set=t(nil)!}
    Stack.LineCopyAdd={AleStackUp}
 Console.OutLn="AleStackUp"
  }
  OpPriority.SmallerExec=LessProg{ // Обработка операции с более низким приоритетом
    Stack.FindAndLast={AleStackUp}
    Stack.SuccessExec={
      Stack.LastDelMk
      OAList.LastPopMk
	 OAList.LastIpOutMk=OpPriority.FindAnd
      OperatWait.ReceivedOutMk=OpPriority.FindAnd
	 OpPriority.SmallerExec=LessProg!
    }
  }
  FUListNew.ReceivedOutMk=OpTranslate.FindAnd
}

AleFinProg{
Lex.ReceiverPopMk
  Stack.FindAndLast={AleStackUp}
  Stack.SuccessExec=AleStackUpProg{ // Программа отработки всех приоритетов операций
    Stack.LastDelMk
    OAList.LastPopMk
    Stack.FindAndLast={AleStackUp}
    Stack.SuccessExec=AleStackUpProg!
  }
  Stack.FindOrLast={IfAtr ForAtr}
  Stack.FailExec={OAList.LastPopMk} // Если не if, то необходимо завершить обработку АЛВ
  Stack.OutMk=Console.OutLn
Console.OutLn="OperatWait else"
OAList.OutMk=Console.OutLn
Console.OutLn="---------------"
Stack.OutMk=Console.OutLn
  OperatWait.ReceivedOutMk=Console.OutLn
  OperatWait.ReceivedOutMk=Lex.SendToReceiver} \* 23.03.2023 *\

>{0 ProgExec=AleFinProg!}


\**\EqAfter.Set= \* 22.03.2023 *\
>{Mk Lex.ReceiverMkSet=EqAleWait4.FindAnd} 
>{Var Lex.ReceiverMkSet=EqAleWait4.FindAnd} 
>{0 Lex.ReceiverMkSet=EqAleAfter.FindAnd
  OAList.LastAttach={FUALUNew.Set}
  OpPriority.FindAnd={Sep="="} // Сброс таблица приоритетов АЛ операторов
Console.OutLn="EqAfter else"
  FUListNew.ReceivedOutMk=Console.OutLn
  FUListNew.ReceivedOutMk=EqAleAfter.FindAnd
}

\**\EqAleWait.Set= \* 22.03.2023 *\
>{Sep="," Lex.ReceiverMkSet=EqAleWait2.FindAnd}
>{Sep="=" Lex.ReceiverMkSet=EqAleAfter.FindAnd}
>{0 Lex.Stop Console.OutLn="Assignment or comma were expected"}

\**\EqAleWait2.Set= \* 22.03.2023 *\
>{Mk Lex.ReceiverMkSet=EqAleWait.FindAnd}
>{Var Lex.ReceiverMkSet=EqAleWait.FindAnd}
>{0 Lex.Stop Console.OutLn="Mk or var were expected"}

\**\EqAleWait3.Set= \* 22.03.2023 *\
>{Sep="," Lex.ReceiverMkSet=EqAleWait2.FindAnd}
>{Sep="=" Lex.ReceiverMkSet=EqAfter.FindAnd}
>{0 Lex.Stop Console.OutLn="Assignment or comma were expected"}

\**\EqAleWait4.Set= \* 22.03.2023 *\
>{Sep="=" Lex.ReceiverMkSet=EqAfter.FindAnd}
>{0 Lex.ReceiverMkSet=EqAleAfter.FindAnd
  OAList.LastAttach={FUALUNew.Set}
  OpPriority.FindAnd={Sep="="} // Сброс таблица приоритетов АЛ операторов
Console.OutLn="EqAleWait4 else"
  EqAfter.ReceivedOutMk=Lex.SendToReceiver
  FUListNew.ReceivedOutMk=Lex.SendToReceiver
}

\**\MkWait.Set=
>{Mk
  FUListNew.LoadReceivedOutMk=MkCalc.Add
Console.OutLn="'.Mk'"
  Lex.UnicAtrSet=Mnemo Lex.UnicMkSet=MnemoTable.FindAnd
  MkCalc.AccumREfOut=t Lex.ReceiverPopSend={Mk=t(nil)!}
}
>{0 Lex.Stop Console.OutLn="Wrong Mk desription"}

Lex.ReceiverMkSet=Root.FindAnd

//Lex.ReceiverMkSet=Console.OutLn

//Lex.Lexing="NewFU={FUType=FUCons Name=""Cons"" Hint=""Консоль""} Cons.Out=""Hello!!! I am the programm!!!"" Cons.OutLn="" End"" "
//Lex.Lexing="Bus.MakeFU=Caps{Cons.Ln=1}"
//Lex.Lexing="Caps >{Cons.Ln=1} >{Cons.Ln=1}"
//Lex.Lexing="Caps >CapsLoad{Cons.Ln=1}"
//Lex.Lexing="Bus.MakeFU=>{Cons.Ln=1} >{Cons.Ln=1}"
//Lex.Lexing="Bus.MakeFU=Caps>yy{Cons.Ln=1}"
//Lex.Lexing="Caps{Cons.Ln=1}"
//Lex.Lexing="NewFU={FUType=FUCons Name=""Cons"" Hint=""Консоль""}  Cons.OutLn= >{Cons.Ln=1}  >{Cons.Ln=1} Cons.OutLn=""End"" "
//Lex.Lexing="NewFU={FUType=FUCons Name=""Cons"" Hint=""Консоль""}  Cons.OutLn= >{Cons.Ln=1}  >{Cons.Ln=11} "
//Lex.Lexing="NewFU={FUType=FUCons Name=""Cons"" Hint=""Консоль""}  Cons.OutLn= >{Cons.Ln=1}  "
//Lex.Lexing="NewFU={FUType=FUCons Name=""Cons"" Hint=""Консоль""}  Cons.OutLn=Cons.OutLn=Cons.Out"
//Lex.Lexing="NewFU={FUType=FUCons Name=""Cons"" Hint=""Консоль""}  Cons.OutLn=Cons.OutLn=Cons.OutLn"
//Lex.Lexing="a=10 b=""str"""
//Lex.Lexing="NewFU={FUType=FUCons Name=""Cons"" Hint=""Консоль""}"
//Lex.Lexing="NewFU={FUType=FUCons Name=""Cons"" Hint=""Консоль""}  Cons.OutLn=temp(Cons.Out)"
//Lex.Lexing="NewFU={FUType=FUCons Name=""Cons"" Hint=""Консоль""} V=[1 5 ""End""]  Cons.OutLn=V"
//Lex.Lexing="a=[]}  Cons.OutLn=Cons.OutLn=Cons.OutLn"
//Lex.Lexing="x=15 x=max(x,10+10) Cons.OutLn=x"
//Lex.Lexing="x=0 x=2+(2+4)*2+3 Cons.OutLn=x"
//Lex.Lexing="x=0.0 Cons.OutLn=sin(-sin(10+10/2)) Cons.OutLn=x"
//Lex.Lexing="x=1.5 Cons.OutLn=sin(1*0.5) Cons.OutLn=x"
//Lex.Lexing="x=1 x=1+1 Cons.OutLn"
//Lex.Lexing="x=0 Cons.OutLn= tern 3-1*3 {2+0*2 else 3+0*2} Cons.OutLn=x"
//Lex.Lexing="x=1 if x{Cons.OutLn=""Yes""} else{Cons.OutLn=""No""}"
//Lex.Lexing="x=1 if x{Cons.OutLn=""Yes""}"
//Lex.Lexing="if 1+1*2 {Cons.OutLn=""Yes""} elif 0{Cons.OutLn=""Elif""} else{Cons.OutLn=""Else No""} Cons.OutLn=""End"""
//Lex.Lexing="if 0 {Cons.OutLn=""Yes""} else{Cons.OutLn=""Else No""}"
//Lex.Lexing="a=[1,2,3,4] Cons.OutLn=a[2]"
//Lex.Lexing="i=13 a=[4,3,2,1] for a>>i Cons.OutLn=i} Cons.OutLn=""End"""
//Lex.Lexing="i=13 after 4:10:2>>i Cons.OutLn=i} Cons.OutLn=""End"""
//Lex.Lexing="i=13 for 2+1:10:2>>i Cons.OutLn=i} Cons.OutLn=""End"""
Lex.Lexing="i=13 for 4-2*2:10:2>>i Cons.OutLn=i next Cons.OutLn=i }else>> Cons.OutLn=""For else""} Cons.OutLn=""End"""
//Lex.Lexing="i=13 i=i+i Cons.OutLn=i"
//Lex.Lexing="i=13 for 2:10:2>>i Cons.OutLn=i if i<4 {Cons.OutLn=i*i} }else>> Cons.OutLn=""For else""} Cons.OutLn=""End"""
//Lex.Lexing="i=13 if 1<5+1 { Cons.OutLn=i*i}"

Lex.SendToReceiver={Sep=""} // Конечный символ после трансляции всего кода программы

Stack.FindAndLast={Sep=">"}
Stack.SuccessExec={OAList.PopMk Stack.LastPopMk Console.OutLn="> out"}

Console.OutLn="***************** MnemoList"
//MnemoTable.OutMk=Console.OutLn

Console.OutLn="***************** OAList"
OAList.OutMk=Console.OutLn

Console.OutLn="-----------------Stack:"
Stack.LineCountOutMK=Console.OutLn
Stack.OutMk=Console.OutLn
Console.OutLn="---- Programm out ----"
OAList.LastOutMk=ALUG.ProgExec
//OAList.LastOutMk=Console.OutLn