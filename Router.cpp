#include "stdafx.h"
#include "consts.h"
#include "Router.h"
#include "FUini.h"

using namespace std;

long int Router::ChennelSearch(long int MK) // Поиск канала по МК (Возврашает -1, если канал не найден)
{
	auto i = Channels.begin();
	for (; i != Channels.end(); i++)
		if (i->Up <= MK < i->Down) break;
		else if (i->Up == i->Down && i->Up==0) break; // Канал по умолчанию
	if (i == Channels.end()) // Канал не нейден
		return -1;
	return distance(Channels.begin(), i); // Вернуть номер канала
}

double Router::DelayGen(channel ch) //Генерация задержки передачи данных
{
	return ch.Delay; // Постоянная задержка
}

void Router::NetRouting(long int MK, LoadPoint Load, FU* Sender) // Маршрутизация в сети ФУ, разделенные на распределенные сетора
{
	MK -= FUMkRange; // Убираем лишний индекс
	vector<int> D; // Дифференциал при отправке по сетке
	// Вычисление дифференциала по первой координате
	D.push_back(((MK / FUMkRange) % ((SectorDim[2] / SectorDim[1]) * SectorDim[0]) / SectorDim[0]) - SectorCoordinate[0]);
	D.push_back((MK / FUMkRange) / SectorDim[2] - SectorCoordinate[1]);
	//	for(int i=1; i<SectorDim.size();i++)
//		D.push_back(MK/FUMkRange - SectorCoordinate[i]);
	int c = 0;
	for (auto i : D)
		if (i != 0) c++;
	c = rand() % c; // Перенаправление случайным образом на один из маршрутов
	for(int i=0; i<SectorDim.size(); i++)
		if (D[i] != 0)
		{
			c--;
			if (!c)
			{
				SectorReceivers[D[i]<0 ? 0: 1]->ProgFU(MK, Load, Sender);
			}
		}
}

void Router::ProgFU(long int MK, LoadPoint Load, FU* Sender)
{
	if (!(MK < FUMkRange || MK >= FUMkGlobalAdr && MK < FUMkGlobalAdr + FUMkRange)) // Routing
	{
//		cout << FUName << " " << MK << endl;
//		Modeling->EventModelingPrint();
		// Маршрутизация
		// SendInd = ChennelSearch(MK); // Определить номер канала, по которому пришла МК для маршрутизации

		if (Modeling != nullptr && Modeling->ManualMode && Modeling->scheduler != nullptr && !Modeling->SchedulerFlag)
		{
			Modeling->SchedulerFlag = false;
			Modeling->qmk.push_back({ MK, Load });
			((Scheduler*)(Modeling->scheduler))->Scheduling(this, RoutingTime);
			return;
		}

		ProgExec(ReceiveProg); // Запустить программу по приходу данных
		MKCount++;
		DataCount += Load.DataSize() + 4;
		if (Modeling != nullptr)
		{
			MaxMKQueue = max(int(MaxMKQueue), (int)Modeling->qmk.size()); // Вычисление максимальной длины очереди
			MaxDataSize =max(int(MaxDataSize), int(DataSize)); // Вычисление максимального объема данных в буфере
			DataSize -= Load.DataSize() + 4; // Обработка МК
		}
		LaslMkIp = {MK,Load}; // Запоминание последней пришедшей для маршрутизации МК
		if (RoutingProg != nullptr)
		{
			ProgExec(RoutingProg); // Запуск програмы ручного управления
			return;
		}
		// Стандартная программа машрутизации
		SendInd = -1;
		for (auto i = Channels.begin(); i != Channels.end(); i++)
			if (i->Up <= MK && MK < (i->Down)){
				SendInd = distance(Channels.begin(), i);
				break;
			}
		if (SendInd >= 0) // Стандартная маршрутизация
		{
			Channels[SendInd].MkOutCount++; // Посчитали МК
			Channels[SendInd].DataOutCount += Load.DataSize();
			//if(Modeling==nullptr)

			((FU*) Channels[SendInd].Receiver)->MkAwait(MK,Load, Sender, DelayGen(Channels[SendInd]));
		}
		else if (SectorDim.size() > 0) // Размерность сетки ненулевая, следовательно сеточная маршрутизация
		{
			
		}

		// Режим моделирования
		if (Modeling!=0)
			((Scheduler*)Modeling->scheduler)->CoreFree();
		// -------------------
	}
	else // МК для роутера
	switch (MK%FUMkRange)
	{
	case 0: // Сброс
		Channels.clear();
		MKCount = 0;
		break;
	// Настройки и управление маршрутизатором
	case 1: // ChCreate Создать новый канал (на входе МК верхняя граница диапазона)
	{
		//if (Load.Point == nullptr) break;
		Channels.push_back({ Load.toInt(-1),0 ,Bus,-1 });
		if (Channels.back().Up >= 0)
			Channels.back().Down = Channels.back().Up + FUMkRange; // Установка верхней границы по умолчанию
		Ind = Channels.size() - 1; // Настроить индекс на последний созданный канал
		break;
	}
	case 2: // RoutingSimulat Эмуляция прихода МК на маршрутизатор
		ProgFU(((IC_type)Load.Point)->begin()->atr, ((IC_type)Load.Point)->begin()->Load);
		break;
	case 3: // IndSet Установить индекс текущего канала роутера
		Ind = Load.toInt();
		break;
	case 5: // RangeSet Установить верхний диапазон МК для роутера (нижний диапазон подразумевается, как верхний плюс диапазон МК)
		FUMkGlobalAdr = Load.toInt();
		break;
	case 6: // RouterTimeSet Установить время маршрутизации
		RoutingTime = Load.toDouble();
		break;
	case 9: // ChRangeUpSet Установить верхний диапазон адресов канала
		Channels[Ind].Up = Load.toInt(-1);
		break;
	case 10: // ChRangeDownSet Установить нижний диапазон адресов канала
	{
		Channels[Ind].Down = Load.toInt(-1);
		//if (Channels.back().Up < 0)
		//	Channels.back().Up = Channels.back().Down + FUMkRange; // Автоматическая установка верхнего предела интервала равного мк-диапазону по умолчанию
		break;
	}
	case 11: // ChGatewaySet Установить ссылку на шлюз для текущего канала связи
		Channels[Ind].Receiver = (FU*)Load.Point;
		break;
	case 15: // ChNumOut Выдать количество каналов на роутере
		Load.Write(Channels.size());
		break;
	case 20: // ChNumOutMk Выдать МК с количеством каналов на роутере
	{
		long int t = Channels.size();
		MkExec(Load, { Cint, &t });
		break;	}
	case 25: // ChGatewayOut Выдать указатель на шлюз для текущего канала
		Load.Write(Channels[Ind].Receiver);
		break;
	case 30: // ChGatewayOutMk Выдать МК с указателем на шлюз для текущего канала
		MkExec(Load, { CFU, &Channels[Ind].Receiver });
		break;
	case 35: // ChRangeUpOut Выдать верхний диапазон адресов для текущего канала
		Load.Write(Channels[Ind].Up);
		break;
	case 40: // ChRangeUpOutMk Выдать МК с верхним диапазоном адресов для текущего канала
		MkExec(Load, { Cint, &Channels[Ind].Up });
	case 45: // ChRangeDownOut Выдать нижний диапазон для текущего канала
		Load.Write(Channels[Ind].Down);
		break;
	case 50:// ChRangeDownOutMk Выдать МК с нижним диапазоном для текущего канала
		MkExec(Load, { Cint, &Channels[Ind].Down });
		break;
	case 51: // ChDelaySet Устанговить константную задержку передачи данных по каналу
		Channels[Ind].Delay = Load.toDouble();
		break;
	//
	// Подпрограммы
	case 55: // RoutingProgSet Установить ссылку на программу маршрутизации
		RoutingProg = Load.Point;
		break;
	case 60: // OverflowProgSet Установить ссылку на подпрограмму реакции на переполнение буфера для хранения данных
		OverflowProg = Load.Point;
		break;
	case 61: // MkOverflowProgSet Установить ссылку на подпрограмму реакции на переполнение буфера МК
		MkOverflowProg = Load.Point;
		break;
	case 62: // RoutindErrProgSet Установить ссылку на программу обработки события адрес МК для маршрутизации не найден в таблице маршрутизации
		RoutingErrProg = Load.Point;
		break;
	case 63: //EventserSet Установить указатель на контроллер событий
		eventser = (Eventser *) Load.Point;
		break;
	// «Ручное» управление
	case 65: // RoutingAttributeOut Выдать атрибут пришедшей для маршрутизации МК
		Load.Write(LaslMkIp.atr);
		break;
	case 66: // RoutingMkOut
	//	Load.Write(LaslMkIp);
		break;
	case 70: // RoutingAttributeOutMk Выдать МК с атрибутом пришедшей для маршрутизации МК
		MkExec(Load, { Cint, &LaslMkIp.atr });
		break;
	case 71: // RoutingAttributeOutMk Выдать МК с атрибутом пришедшей для маршрутизации МК
		MkExec(Load, { CIP, &LaslMkIp });
		break;
		//	case 85: // ChRoutingMkOut Выдать индекс канала, по которому пришла последняя МК для маршрутизации
//		Load.Write(Ind);
//		break;
//	case 90: // ChRoutingMkOutMk Выдать МК с каналом, по которому пришла последняя МК для маршрутизации
//		MkExec(Load, { Cint, &Channels[Ind] });
//		break;
	case 105: // Переслать последнюю МК в канал с номером (номер канала в нагрузке МК для роутера)
		Channels[Load.toInt()].Receiver->ProgFU(LaslMkIp.atr, LaslMkIp.Load, this);
		break;
//	case 120: // ReceiveIndOut
//		Load.Write(SendInd);
//		break;
//	case 125: // ReceiveIndOutMk Выдать МК с индексом канала, на который пришел пакет для маршрутизации
//		MkExec(Load, { Cint, &SendInd });
//		break;
	//
	// Блок статистики
	case 320: // RouterStatsClear Сбросить блок статистики переданных данных через роутер
		MKCount = 0;
		MaxMKQueue = 0;
		//AverageMKQueue = 0;
		for (auto i = Channels.begin(); i != Channels.end(); i++)
		{
			i->MkOutCount = 0;
			i->DataOutCount = 0;
		};
		break;
	case 325: // RouterDataCountOut Выдать объем переданных данных через роутер
	{
		int sum = 0;
		for (auto i = Channels.begin(); i != Channels.end(); i++)
			sum += i->DataOutCount;
		Load.Write(sum);
		break;
	}
	case 330: // RouterDataCountOutMk Выдать МК с объемом переданных данных через роутер
	{
		int sum = 0;
		for (auto i = Channels.begin(); i != Channels.end(); i++)
			sum += i->DataOutCount;
		MkExec(Load, { Cint, &sum });
		break;
	}
	case 335: // ChDataOutCountOut Выдать объем переданных данных из текущего канала (по индексу текущего канала)
		Load.Write(Channels[Ind].DataOutCount);
		break;
	case 336: // ChDataInCountOut Выдать объем пришедших данных в текущий канал (по индексу текущего канала)
		Load.Write(Channels[Ind].DataInCount);
		break;
	case 340: // ChDataOutCountOutMk Выдать МК с объемом переданных данных переданных из канала
		MkExec(Load, { Cint, &Channels[Ind].DataOutCount });
		break;
	case 341: // ChDataInCountOutMk Выдать МК с объемом пришедших данных в канал
		MkExec(Load, { Cint, &Channels[Ind].DataInCount });
		break;
	case 345: // RouterMkCountOut Выдать количество переданных МК через роутер
		Load.Write(MKCount);
		break;
	case 350: // RouterMkCountOutMk Выдать МК с количеством переданных МК через роутер
		MkExec(Load, { Cint, &MKCount });
		break;
	case 355: // ChMkInCountOut Выдать количество переданных МК через канал
		Load.Write(Channels[Ind].MkOutCount);
		break;
	case 360: // ChMkInCountOutMk Выдать МК с количеством переданных МК через канал
		MkExec(Load, { Cint, &Channels[Ind].MkOutCount });
		break;
	case 365: // RouterMaxMkQueueOut Выдать макс длину очереди МК на роутере
		Load.Write(MaxMKQueue);
		break;
	case 370: // RouterMaxMkQueueOutMk Выдать МК с макс длиной очереди МК на роутере
		MkExec(Load, { Cint, &MaxMKQueue });
		break;
	case 375: // RouterAverageMkQueueOut Выдать среднюю длину очереди МК на роутере
		Load.Write((double) DataCount / MKCount);
		break;
	case 380: // RouterAverageMkQueueOuMk Выдать МК со средней длиной очереди МК на роутере
	{
		double t = (double)DataCount / MKCount;
		MkExec(Load, { Cdouble, &t });
	}
		break;
	case 395: // ReceiveProgSet Установить ссылку на программу, активизирующуюся при приходе МК для маршрутизации (для реализации автоматического сбора статистики)
		ReceiveProg = Load.Point;
		break;

	case 450: // SectorClear Очистить размерность распределенной вычислительной сетки и индексы
		SectorDim.clear();
		SectorCoordinate.clear();
		SectorReceivers.clear();
		break;
	case 451: // SectorDimAdd // Добавить размерность измерения
		SectorDim.push_back(Load.toInt());
		break;
	case 452: // SectorCoordinateAdd Добавить координату сектора
		SectorCoordinate.push_back(Load.toInt());
		break;
	case 453: // SectorRouterAdd Добавить секторальный роутер
		SectorReceivers.push_back((Router*)Load.Point);
	default:
		CommonMk(MK, Load, Sender);
		break;
	}
}

FU* Router::Copy() // Программа копирования ФУ
{
	return new Router(Bus, this);
}

FU* Router::TypeCopy() // Создать ФУ такого же типа (не копируя контекст
{
	return new Router(Bus, nullptr);
}
